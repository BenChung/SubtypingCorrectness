\documentclass[a4paper,english]{lipics-v2019}
\usepackage{wrapfig,microtype,amssymb,amsmath,stmaryrd,mathpartir,array,graphicx,tabularx,xspace}
\usepackage[table]{xcolor}
\newcommand{\xt}[1]{\texttt{#1}}
%\newcommand{\tupleo}[1]{\xt{Tuple1\{}#1\xt{\}}}
\newcommand{\tuplet}[2]{\xt{Tuple\{}#1,#2\xt{\}}}
\newcommand{\union}[2]{\xt{Union\{}#1,#2\xt{\}}}
\newcommand{\denotes}[1]{\llbracket #1 \rrbracket}

\renewcommand{\L}{{\tt L}\xspace}
\newcommand{\Ls}{{\tt L}s\xspace}
\newcommand{\R}{{\tt R}\xspace}
\newcommand{\Rs}{{\tt R}s\xspace}
\newcommand{\uL}{{\underline{\tt L}}\xspace}
\renewcommand{\c}[1]{\ensuremath{\text{\lstinline{#1}}}\xspace}

%FZ
\newcommand{\sub}{<:}
\newcommand{\tuple}[1]{\xt{Tuple\{}#1\xt{\}}}
\newcommand{\arrayt}[1]{\xt{Array\{}#1\xt{\}}}
\newcommand{\FZ}[1]{\textbf{FZ says: #1}}
%end FZ

\newcommand{\goodcell}{\cellcolor{green!25}}
\newcommand{\badcell}{\cellcolor{red!25}}
\bibliographystyle{plainurl}% the recommnded bibstyle
\title{Julia's efficient algorithm for subtyping unions and covariant tuples}
\titlerunning{Subtyping union types and covariant tuples}

\author{Benjamin Chung}{Northeastern University}{}{}{}%mandato
\author{Francesco Zappa Nardelli}{Inria}{}{}{} \author{Jan
  Vitek}{Northeastern University \& Czech Technical University in
 Prague}{}{}{}
\authorrunning{B. Chung, F. Zappa Nardelli, J. Vitek}
\Copyright{Benjamin Chung, Francesco Zappa Nardelli, Jan Vitek}%mandatory, plea
\ccsdesc[500]{Theory of computation~Type theory}
\keywords{Type systems, Subtyping, Union types}

\lstset{
 language=caml,
 columns=[c]fixed,
 basicstyle=\small\ttfamily,
 keywordstyle=\bfseries,
 upquote=true,
 commentstyle=,
 breaklines=true,
 showstringspaces=false}

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{ECOOP}
\EventAcronym{ECOOP}
\EventYear{2019}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle
\begin{abstract}
  The Julia programming language supports multiple dispatch and provides a
  rich type annotation language to specify method applicability. When
  multiple methods are applicable for a given call, Julia relies on
  subtyping between method signatures to pick the method to invoke. Julia's
  subtyping algorithm is surprisingly complex, and deciding whether it is
  correct remains an open question. In this paper, we focus on one piece of
  this problem: the interaction between union types and covariant
  tuples. Previous work that addressed this particular combination of
  features did so by normalizing types to a disjunctive normal form
  ahead-of-time. Normalization is not practical due to space-explosion for
  complex type signatures and to interactions with other features of Julia's
  type system.  Our contribution is a description of the algorithm
  implemented in the Julia run-time system. This algorithm is immune to the
  space-explosion and expressiveness problems of standard algorithms.  We
  prove this algorithm correct and complete against a semantic-subtyping
  denotational model in Coq.
\end{abstract}

\section{Introduction}

Union types, originally introduced by Barbanera and
Dezani-Ciancaglini~\cite{barbanera1991intersection}, are increasingly being
used in mainstream languages. In some cases, such as Julia~\cite{BezansonEKS17}
or TypeScript~\cite{typescript}, they are exposed at the source level. In
others, such as Hack~\cite{hack}, they are only used internally for
type inference. We describe a space-efficient technique for
computing subtyping between types in the presence of distributive unions,
arising from the Julia programming language. In our previous
work on formalizing the Julia subtyping
algorithm~\cite{DBLP:NardelliBPCBV18}, we described the subtyping relation
but were unable to describe the subtyping algorithm or prove it
correct. Indeed, we found bugs and were left with unresolved issues.

Julia's subtyping algorithm is an important part of its semantics. Julia is
a dynamically typed language where methods are annotated with type
signatures to enable multiple dispatch. During program execution, Julia must
determine which method to invoke at each call site. It does so by finding
the most specific applicable method (according to subtyping) that applies
for a given invocation. For example, the following snippet shows three declarations of
multiplication.

\begin{lstlisting}
 *(x::Number, r::Range)  = range(x*first(r),...)
 *(x::Number, y::Number) = *(promote(x,y)...)
 *(x::T, y::T) where T <: Union{Signed,Unsigned} =  mul_int(x,y)
\end{lstlisting}

\noindent The first two methods implement, respectively, the case where a
range is multiplied by a number and generic numeric multiplication. The
third method invokes native multiplication when both arguments are either
signed or unsigned integers (but not a mix of the two). Julia will use subtyping
to decide which of the methods will be invoked for any specific invocation. 

To allow the expression of complex relationships in type signature, Julia offers programmers a rich type language. Julia's types include nominal single
subtyping, union types, existential types, covariant tuples, invariant
parametric datatypes, and singleton types. These features are widely used in
libraries, but pose challenges for subtyping. The design of subtyping was
inspired by semantic subtyping~\cite{Frisch02,BezansonEKS17}, and while Julia's 
types do not precisely abide by a semantic set-theoretic intuition, its subtyping
algorithm must handle many of the same problems.

This paper documents the first steps towards proving the correctness of
Julia's subtyping algorithm. We focus on the interaction of two features:
union types and covariant tuples. Tuples are used to represent function
signatures, as Julia does not record return types. They are covariant, as a
function with more specific arguments is preferred to a more generic one.
Union types are used as shorthand to avoid writing multiple
functions with the same body.  Rules for subtyping union types and covariant
tuples have been known for a long time. Based on Vouillon~\cite{Vouillon04},
the following is a typical deductive system:

\vspace{-4mm}{\small\begin{mathpar}
\inferrule[allexist]{
   t' \sub t \\ t'' \sub t}{\union{t'}{t''} \sub t}

\inferrule[existL]{t \sub t'}{t \sub \union{t'}{t''}}

\inferrule[existR]{t \sub t''}{t \sub \union{t'}{t''}}

\inferrule[tuple]{t_1 \sub t'_1 \\ t_2 \sub t'_2}{\tuple{t_1, t_2} \sub \tuple{t'_1, t'_2}}
\end{mathpar}}
\vspace{-4mm}

\noindent While this rule system makes sense, it does not match the
semantic intuition for subtyping. If we think of types as sets of
values~\cite{Pierce1991}, we would expect that a union type would be
analogous to a set theoretic union. Similarly, we would then expect that two
types would be subtypes if their sets of values were subsets.  Therefore,
when a union type appears on the left-hand side of a judgment, \emph{all}
its components must be subtypes of the right-hand side; when a union type
appears on the right-hand side of a judgment, there must \emph{exist} a
component that is a supertype of the left-hand side. The above
system of rules violates these ideas. Consider the following judgment:

%
\vspace{-5.5mm}{\small\[
\tuple{\union{t'}{t''}, t} \ \ \sub\ \ \union{\tuple{t', t}}{\tuple{t'', t}} 
\]}
\vspace{-6mm}
%

\noindent Using the semantic subtyping intuition, the judgment should hold. We write the
set of values denoted by the type $t$ as {\small $\llbracket t \rrbracket$}.
The left hand side denotes the values {\small $\{\tuple{v',v''} ~|~ v' \in
  \llbracket t' \rrbracket \cup \llbracket t'' \rrbracket \wedge v'' \in
  \llbracket t \rrbracket\}$}, while the right hand side denotes {\small
  $\llbracket \tuple{t', t} \rrbracket \cup \llbracket \tuple{t'', t}
  \rrbracket$}.  Obviously, the sets are the same. However, we cannot derive
this relation from the above rules. According to them, we must pick either
{\small $t'$} or {\small $t''$} on the right hand side, ending up with either {\small
  $\tuple{\union{t'}{t''}, t} \sub \tuple{t', t}$} or {\small
  $\tuple{\union{t'}{t''}, t} \sub \tuple{t'', t}$}. In either case, the
judgment does not hold. How can this problem be solved?

Some early work~\cite{barbanera1991intersection,Pierce1991,aiken1991implementing} uses
normalization to decide distributive subtyping between union types, while
Vouillon~\cite{Vouillon04} does not handle distributivity. Normalization remains popular, with
Muelbrock and Tate using it in their general framework for union and itersection types~\cite{muehlboeck2018empowering}. Normalization
entails rewriting all types into their disjunctive normal form, as unions of
union-free types, \emph{before} building the derivation. This lifts all
choices to the top level, avoiding the structural entanglements that cause
trouble. The correctness of this rewriting step comes from the
semantic-subtyping denotational model~\cite{Frisch08}, and the resulting
subtype algorithm can be proved both correct and complete. However, this
algorithm has two major drawbacks: it is not space efficient, and it does not
interact well with other features of Julia.

The first drawback is that normalization can lead to exponentially
bigger types. Real-world Julia code has types like the
following~\cite{DBLP:NardelliBPCBV18} whose normal form has 32,768
constituent union-free types, making it impractical to store or to compute with:

\vspace{-2mm}
\begin{small}
\begin{verbatim}
 Tuple{Tuple{Union{Int64, Bool}, Union{String, Bool}, Union{String, Bool}, 
             Union{String, Bool}, Union{Int64, Bool}, Union{String, Bool}, 
             Union{String, Bool}, Union{String, Bool}, Union{String, Bool}, 
             Union{String, Bool}, Union{String, Bool}, Union{String, Bool}, 
             Union{String, Bool}, Union{String, Bool}, Union{String, Bool}}, Int64}
\end{verbatim}
\end{small}
\vspace{-2mm}

The second drawback of normalization is that it does not interact well with
other features of the type system. In particular, Julia supports invariant
constructors, which are incompatible with union normalization. For example,
the type $\arrayt{\xt{Int}}$ is an array of integers, and is not a
subtype of $\arrayt{\xt{Any}}$. This seemingly simple feature, in
conjunction with type variables, makes normalization ineffective.  Consider
the type {\small \(\arrayt{\union{t'}{t''}}\)}. This type denotes the set of
arrays whose elements are either of type {\small $t'$} or {\small $t''$}.
It would be incorrect to rewrite it as {\small
  \(\union{\arrayt{t'}}{\arrayt{t''}}\)}, as this latter type denotes the
set of arrays whose elements are either all of type {\small $t'$} or all of
type {\small$t''$}. A weaker disjunctive normal form, only lifting union
types inside each invariant constructor, can circumvent this
problem. However, doing so only to reveals a deeper problem caused by the presence
of both invariant constructors and {existential types}. This is illustrated
by the following judgment:

%
\vspace{-4mm}{\small\[
  \arrayt{\union{\tuple{t}}{\tuple{t'}}} \ \ <:\ \ \exists T\,.\, \arrayt{\tuple{T}}
\]}\vspace{-4mm}
%

\noindent 
This judgment holds if we set the existential {\small$T=\union{t}{t'}$}.
Since all types are in weak normal form, an algorithm based on the standard
system of judgment rules would strip off the array type constructors and
proceed.  However, since type constructors are invariant on their arguments,
it must first test that the relation holds in the original order (e.g. that
{\small$\union{\tuple{t}}{\tuple{t}}<:\tuple{T}$}) and in the reverse order
(that {\small$\tuple{T}<:\union{\tuple{t}}{\tuple{t'}}$}). It is in this
combined check that we run into problems.
%
The subtype check conducted in the original order can be concluded without issue, producing
the constraint {\small$\union{t}{t'} <: T$}. However, this constraint
on $T$ is stored for checking the reversed direction of subtyping, which is
where the problems arise. When we check the opposite subtype order, we end
up having to prove that {\small$\tuple{T}<:\union{\tuple{t}}{\tuple{t'}}$}
and in turn either {\small$T<:t$} or {\small$T<:t'$}. All of these are
unprovable under the assumption that {\small$\union{t}{t'} <: T$}.
%
The key to derive a successful judgment for this relation is to rewrite the
right-to-left check into {\small$\tuple{T}<:\tuple{\union{t}{t'}}$}, which is
provable. This \emph{anti-normalisation} rewriting must be performed on
sub-judgments of the derivation, and to the best of our knowledge it is not
part of any subtype algorithm based on ahead-of-time disjunctive
normalisation. As a result, straightforward normalization, even to a relaxed
normal form, is incompatible with the full Julia type system.

The complete Julia subtype algorithm is implemented in close to two thousand
lines of highly optimized C code. This paper addresses only one part of that
algorithm, the technique used to avoid space explosion while dealing with
union types and covariant tuples. This is done by defining an iteration
strategy over type terms, keeping a string of bits as its state. The space
requirement of the algorithm is bounded by the number of unions in the type
terms being checked. We prove in Coq that the algorithm is correct and
complete with respect to a standard semantic subtyping model.

We have chosen a minimal language with union, tuples, and primitive types to
avoid being drawn into the vast complexity of Julia's type algebra. This tiny
language is expressive enough to highlight the decision strategy, and make
this implementation technique known to a wider audience. The full Julia
implementation shows that this technique extends to to invariant constructors
and existential types~\cite{DBLP:NardelliBPCBV18}, among others. We expect
that it can be leveraged in other modern language designs.

\medskip
Our mechanized proof is available at: {\small\url{benchung.github.io/subtype-artifact}}.
\newpage

\section{A space-efficient subtyping algorithm}

Let us focus on a core type language consisting of binary unions, binary
tuples and primitive types ranged over by $p_1 \dots p_n$ where primitive
type subtyping is identity, $p_i <: p_i$.

\medskip
\begin{lstlisting}
type typ =   Prim of int  | Tuple of typ * typ  | Union of typ * typ
\end{lstlisting}
\medskip

\subsection{Normalization}\label{normalize}

Using normalization to determine subyping entails rewriting tuples so that
unions occur at the top level. Consider the following query:

\medskip
$\union{ \tuple{p_1,p_2}}{\tuple{p_2,p_3}} ~~ <:~~  \tuple{ \union{p_2}{p_1}, \union{p_3}{p_2}}$
\medskip

\noindent
The term on the left is normal form, but the right term  needs to be
rewritten as follows:

\medskip
$\union{ \tuple{p_2,p_3}}
  {\union{ \tuple{p_2,p_2}}
    {\union{ \tuple{p_1,p_3}}
           {\tuple{p_1,p_2}}}}$
\medskip

\noindent
Given normalized types, one more step of rewriting gives us union-free
lists of tuples,

\medskip
$\ell_1 = \{  \tuple{p_1,p_2}, \tuple{p_2,p_3}  \}$
\medskip

\noindent and

\medskip
$\ell_2 = \{  \tuple{p_2,p_3}, \tuple{p_2,p_2}, \tuple{p_1,p_3}, 
          \tuple{p_1,p_2} \}$.
\medskip

\noindent determining whether $\ell_1 <: \ell_2$ boils down to checking that
for each element in $\ell_1$ there should be an element in $\ell_2$ such
that the tuples are subtypes. Intuitively this mirrors the above defined
rules ({\sc [allexist]}, {\sc [existL/R]}, {\sc [tuple]}). As for Julia's
algorithm, the intuition is that one can avoid normalization by iterating
over the original type terms and visiting every one of the elements of
$\ell_1$ and $\ell_2$ without having to materialize those sets. The
remainder of this section explains how this is done.

A possible implementation of normalization-based subtyping can be written
compactly.  The \c{subtype} function takes two types and returns true if
they are related by subtyping. It delegates its work to \c{allexist} to
check that all normalized terms in its first argument have a super-type, and
to \c{exist} to check that there is at least one super-type in the second
argument.  The \c{norm} function takes a type term and returns a list of
union-free terms.

\begin{lstlisting}
let subtype(a:typ)(b:typ) = allexist (normalize a) (normalize b)

let allexist(a:typ)(b:typ) = 
  foldl (fun acc a' => acc && exist a' b) true a

let exist(a:typ)(b:list typ) = 
  foldl (fun acc b' => acc ||  a==b') false b

let rec normalize = function
  | Prim i -> [Prim i]
  | Tuple t t' -> 
      map_pair Tuple (cartesian_product (normalize t) (normalize t'))
  | Union t t' -> (normalize t) @ (normalize t')
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Iteration with Choice Strings}\label{cs}

Given a type term such as the following,

\medskip
$\tuple{ \union{ \union{p_2}{p_3} }{p_1}, \union{p_3}{p_2}}$
\medskip

\noindent
we are looking for an iteration sequence that will yield the following tuples,

\medskip
\noindent $\tuple{p_2,p_3}, ~ \tuple{p_2,p_2}, ~ \tuple{p_1,p_3}, ~ \tuple{p_1,p_2}, ~
  \tuple{p_3,p_3}, ~ \tuple{p_3,p_2}$.
\medskip\vspace{-3mm}

\noindent
An alternative representation for the term is a tree, where each occurence
of union node is a \emph{choice point}. The following tree thus has three
choice points.
\medskip

\includegraphics[scale=.25]{figures/tree1.pdf}
\smallskip

\noindent
At each choice point we can go either left or right, making such a decision
at each points leads to visit one particular tuple.

\medskip
{\small
\begin{tabular}{@{}l@{~}ll@{~}ll@{~}ll@{~}l}
\begin{minipage}{1.2cm}\includegraphics[scale=.25]{figures/tree2.pdf} 
\end{minipage} &  $ =   \tuple{p_2,p_3} $ &
\begin{minipage}{1.2cm}\includegraphics[scale=.25]{figures/tree3.pdf} 
\end{minipage} &  $ =   \tuple{p_2,p_2} $ 
&\begin{minipage}{1.2cm}\includegraphics[scale=.25]{figures/tree4.pdf} 
\end{minipage} &  $ =   \tuple{p_2,p_3} $ \\
\begin{minipage}{1.2cm}\includegraphics[scale=.25]{figures/tree5.pdf} 
\end{minipage} &  $ =   \tuple{p_2,p_2} $  &
\begin{minipage}{1.2cm}\includegraphics[scale=.25]{figures/tree6.pdf} 
\end{minipage} &  $ =   \tuple{p_3,p_2} $ 
&\begin{minipage}{1.2cm}\includegraphics[scale=.25]{figures/tree7.pdf} 
\end{minipage} &  $ =   \tuple{p_3,p_3} $ 
\end{tabular}}

\medskip
\noindent 
Each tuple is uniquely determined by the original type term $t$ and a choice
string $c$. In the above example, the result of iteration through the
normalized, union-free, type terms is defined by the strings \L\L\L, \L\L\R,
\L\R\L, \L\R\R, \R\L, \R\R. The length of each string is bounded by the
number of unions in a term.


The iteration sequence in the above example is thus \L\L\uL $\rightarrow$
\L\uL\R $\rightarrow$ \L\R\uL $\rightarrow$ \uL\R\R $\rightarrow$ \R\uL
$\rightarrow$ \R\R. Stepping from a choice string $c$ to the next string
consists of splitting $c$ in three, $c' \,\L\,c''$, where $c'$ can be empty
and $c''$ is a possibly empty sequence of \R.  The next string is $c'\, \R
\, c_{pad}$, that is to say it retains the prefix $c'$, toggles \L to \R,
and is padded by a sequence of \Ls.  If there is no \L in $c$, iterations has
terminated.

One step of iteration is performed by calling the \c{next} function with a
type term and a choice string. \c{next} either returns the next string in
the sequence or \c{None}. Internally, it calls on \c{step} to toggle the
last \L and shorten the string (constructing $c'\,\R$). Then it call on
\c{pad} to add the trailing sequence of \Ls (constructing $c'\,\R\,c_{pad}$).

\begin{lstlisting}
type choice = L | R

let rec next(a:typ)(l:choice list) = 
  match step l with
   | None -> None
   | Some(l') -> Some(fst (pad a l'))
\end{lstlisting}

\noindent
The \c{step} function delegates the job of flipping the last occurrence of
\L to \c{toggle}. For ease of programming, it reverses the string so that
\c{toggle} can be a simple recursion without an accumulator.  If the given
string has no \L, then \c{toggle} returns empty, and \c{step} returns
\c{None}.
\newpage

\begin{lstlisting}
let step(l:choice list) =
  match rev (toggle (rev l)) with
  | [] -> None
  | hd::tl -> Some(hd::tl)

let rec toggle = function
  | [] -> []    
  | L::tl -> R::tl
  | R::tl -> toggle tl
\end{lstlisting}

\noindent
The \c{pad} function takes a type term and a choice string to be padded. It
returns a pair, the first element is the padded string and the second is
remaining string. \c{pad} traverses the term, visiting both side of each
tuple, and for unions it uses the given choice string to direct its visit.
Each union encountered consumes a character out of the input string, once
the string is fully consumed, any remaining unions are treated as if there
was a \L. The first component of the returned value is the choice given as
argument extended with a number of \L corresponding to the number of unions
encountered after string ran out.

\begin{lstlisting}
let rec pad t l =
   match t,l with
   | (Prim i,l) -> ([],l)
   | (Tuple(t,t'),l) -> 
      let (h,tl) = pad t l in
      let (h',tl') = pad t' tl in (h @ h',tl')
   | (Union(t,_),L::r) -> 
      let (h,tl) = pad t r in (L::h,tl)
   | (Union(_,t),R::r) -> 
      let (h,tl) = pad t r in (R::h,tl)
   | (Union(t,_),[]) -> (L::(fst(pad t [])),[])
\end{lstlisting}

\noindent
To obtain the initial choice string, the string only composed of \Ls, it
suffices to call \c{pad} with the type term under consideration and an empty
list. The first element of the returned tuple is the initial choice
string. For convenience, we define the function \c{initial} for this.

\begin{lstlisting}
let initial(t:typ) = fst (pad t [])
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Subtyping with Iteration}

Julia's subtyping algorithm visits union-free type terms using choice
strings to iterate over types.  The \c{subtype} function takes two type
terms, \c a and \c b, and returns true if they they are related by
subtyping. It does so by iterating over all union-free type terms in \c a,
and checking that for each of them, there exists a union-free type term in
\c b that is a super-type.

\begin{lstlisting}
let subtype(a:typ)(b:typ) = allexist a b (initial a)
\end{lstlisting}

\noindent
The \c{allexist} function take two type terms, \c a and \c b, and a choice
string \c f, and return true if \c a is a subtype of \c b for the iteration
sequence starting at \c f. This is achieved by recursively testing that for
each union-free type term in \c a (induced by \c a and the current value of
\c f), there exists a union-free super-type in \c b.

\newpage
\begin{lstlisting}
let rec allexist(a:typ)(b:typ)(f:choice list) =
  match exist a b f (initial b) with 
  | true -> (match next a f with
             | Some ns -> allexist a b ns 
             | None -> true) 
  | false -> false
\end{lstlisting}

\noindent
Similarly, the \c{exist} function takes two type terms, \c a and \c b, and
choice strings, \c f and \c e. It returns true if there exists in \c b, a
union-free super-type of the type specified by \c f in \c a. This is done by
recursively iterating through \c e. The determination if two terms are
related is delegated to the \c{sub} function.

\begin{lstlisting}
type res = NotSub | IsSub of choice list * choice list

let rec exist(a:typ)(b:typ)(f:choice list)(e:choice list) =
  match sub a b f e with 
  | IsSub(_,_) -> true 
  | NotSub -> 
     (match next b e with
      | Some ns -> exist a b f ns 
      | None -> false) 
\end{lstlisting}

\noindent
Finally, the \c{sub} function take two type terms and two choice strings and
return a value of type \c{res} which can be \c{NotSub} to indicate that the
types are not subtypes or \c{IsSub(_,_)} when they are.  If the two types
are primitives, then they are only subtypes if they are equal.  If the types
are tuples, they are subtypes is both of their elements are subtypes. Note
that the return type of \c{sub}, when successful, hold the unused choice
strings for both type arguments. When confronted with a union, \c{sub} will
follow the choice strings to decide which branch to take. Consider for
instance the case when the first type term is \c{Union(t1,t2)} and the
second is type \c{t}, if the first element of the choice string is an \L,
then \c{t1} and \c{t} will be checked, otherwise \c{sub} will check \c{t2}
and \c{t}.

\begin{lstlisting}
let rec sub t1 t2 f e =
 match t1,t2,f,e with 
 | (Prim i,Prim j,f,e) -> if i==j then IsSub(f,e) else NotSub
 | (Tuple(a1,a2), Tuple(b1,b2),f,e) ->
    (match sub a1 b1 f e with
     | IsSub(f', e') -> sub a2 b2 f' e'
     | NotSub -> NotSub)
 | (Union(a,_),b,L::f,e) -> sub a b f e
 | (Union(_,a),b,R::f,e) -> sub a b f e
 | (a,Union(b,_),f,L::e) -> sub a b f e
 | (a,Union(_,b),f,R::e) -> sub a b f e
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Further optimization}

We have presented an implementation that used lists to represent choice
strings. It thus required allocation when adding elements to the list and
for reversing the list. In Julia, choice strings are represented by bit
vectors of size bounded by the number of unions in each type term.  Once
that size is known and the bit vector is created, no further allocation is
required.
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Correctness and Completeness of Subtyping}

To prove the correctness of Julia's subtyping we take the following general
approach. We start by giving a denotational semantics for types from which
we derive a definition of semantic subtyping. Then we easily prove that a
normalization-based subtyping algorithm is correct and complete. Rather than
directly working with the notion of choice strings as iterators over types,
we start with a simpler structure, namely that of iterators over the trees
induced by type terms. We prove correct and complete a subtype algorithm
that uses these simpler iterators. Finally, we establish a correspondance
between tree iterators and choice list iterators. This concludes our proof
of correctness and completeness, details can be found in the Coq
mechanization.

The denotational semantics we use for types is as follows:

\vspace{-5mm}
\begin{align*}
\denotes{p_i} &= \{p_i\} \\
\denotes{\union{t_1}{t_2}} &= \denotes{t_1} \cup \denotes{t_2} \\
\denotes{\tuplet{t_1}{t_2}} &= \{\tuplet{t'_1}{t'_2} \,|\, t_1' \in \denotes{t_1},  t_2' \in \denotes{t_2'}\}
\end{align*}
\vspace{-5mm}

\noindent
We define subtyping as follows, if $\denotes{t}\subseteq\denotes{t'}$, then
$t<:t'$.  This leads to the definition of subtyping in our restricted language.

\begin{definition}
The subtyping relation $t_1 <: t_2$ holds iff $\forall t_1' \in
\denotes{t_1}, \exists\, t_2' \in \denotes{t_2}, t_1' =
t_2'$.\label{dfn:scr}
\end{definition}

\noindent
The use of equality for relating types is a simplification afforded by the
structure of primitives.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Subtyping with Normalization}

The correctness and completeness of the normalization-based subtyping
algorithm of Section~\ref{normalize} requires proving that the \c{normalize}
function returns all union-free type terms.

\begin{lemma}[NF Equivalence]\label{lem:equiv_ndet}
$t' \in \denotes{t}$ iff $t' \in \c{normalize}~ t$.
\end{lemma}

\noindent
Theorem~\ref{nsf} states that the \c{subtype} relation of
Section~\ref{normalize} abides by Definition~\ref{dfn:scr} because it uses
\c{normalize} to compute the set of union-free type terms for both argument
types, and directly checks subtyping.

\begin{theorem}[NF Subtyping]\label{nsf}
For all  a and b, \c{subtype} a b iff $a <: b$.
\end{theorem}

\noindent
Therefore, normalization based subtyping is correct against our definition.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Subtyping with Tree Iterators}

Reasoning about iterators that use choice strings, as described in
Section~\ref{cs}, is tricky as it requires simultaneously reasoning about
the structure of the type term and the validity of the choice string that
represents the iterator's state. Instead, we propose to use an intermediate
data structure called a tree iterator to tie the two together and thus makes
reasoning simpler.

A tree iterator is a representation of the iteration state embedded in a
type term. Thus a tree iterator yields a union-free tuple, and given a type
term, a tree iterator can either step to a successor state or is a final
state. Recalling the graphical notation of Section~\ref{cs}, we can
represent the state of iteration as a combination of type term and a choice
or, equivalently, as a tree iterator.

\medskip
{\small
\begin{tabular}{@{}l@{~}ll@{~}ll@{~}ll@{~}l}
\it Choice string: &&  \multicolumn{2}{l}{\it Tree iterator:}\\[2mm]
\begin{minipage}{1.2cm}\includegraphics[scale=.25]{figures/tree1.pdf} 
\end{minipage} , \R\L & $ =   \tuple{p_1,p_3} $ 
&\begin{minipage}{1.2cm}\includegraphics[scale=.25]{figures/tree8.pdf}
\end{minipage}& $=\tuple{p_1,p_3}$
\end{tabular}}

\noindent
This structure-dependent construction makes tree iterators less efficient
than choice strings. A tree iterator must have a node for each structural
element of the type being iterated over, and is thus less space-efficient
than the simple choices-only strings. However, it is easier to prove
subtyping correct for tree iterators first.

Tree iterators depend on the type term they iterate over. The possible
states are \c{IPrim} at primitives, \c{ITuple} at tuples, and for unions
either \c{ILeft} or \c{IRight}.

\begin{lstlisting}
Inductive iter: Typ -> Set :=
| IPrim : forall i, iter (Prim i)
| ITuple : forall t1 t2, iter t1 -> iter t2 -> iter (Tuple t1 t2)
| ILeft : forall t1 t2, iter t1 -> iter (Union t1 t2)
| IRight : forall t1 t2, iter t2 -> iter (Union t1 t2).
\end{lstlisting}

\noindent
The \c{next} function for tree iterators steps in a depth-first,
right-to-left order.  We have four cases to worry about. For a primitive
type, there is no successor state. A tuple steps its second child; if that
has no successor step, then it steps its first child and reset the second
child. When given a \c{ILeft} or an \c{IRight} it tries step it only
child. If the child has no successor, an \c{ILeft} steps to an \c{IRight}
and its child is set to the right child of the corresponding node in the
type term.

\begin{lstlisting}
Fixpoint next(t:Typ)(i:iter t): option(iter t) := match i with
  | IPrim _ => None
  | ITuple t1 t2 i1 i2 =>
    match (next t2 i2) with
    | Some i' => Some(ITuple t1 t2 i1 i')
    | None =>
      match (next t1 i1) with
      | Some i' => Some(ITuple t1 t2 i' (start t2))
      | None => None
      end
    end
  | ILeft t1 t2 i1 =>
    match (next t1 i1) with
    | Some(i') => Some(ILeft t1 t2 i')
    | None => Some(IRight t1 t2 (start t2))
    end
  | IRight t1 t2 i2 => 
    match (next t2 i2) with
    | Some(i') => Some(IRight t1 t2 i')
    | None => None
    end
  end.
\end{lstlisting}
% todo: describe induction principle 
% text just below theorem 4 is sensible but could be expanded a bit
% put theorems below figure 

\noindent
An induction principle for tree iterators is needed to reason about all
iterator states for a given type. First, we show that iterators eventually
reach a final state. This is done with function \c{inum} that assigns
natural numbers to each state. It simply counts the number of remaining
steps in the iterator, using \c{tnum} to count the total number of
union-free types denoted by some type \c{t} as a helper.

\newpage

\begin{lstlisting}
Fixpoint tnum(t:Typ):nat :=
  match t with
  | Prim i => 1
  | Tuple t1 t2 => tnum t1 * tnum t2
  | Union t1 t2 => tnum t1 + tnum t2
  end.

Fixpoint inum(t:Typ)(ti:iter t):nat :=
  match ti with
  | IPrim i => 0
  | ITuple t1 t2 i1 i2 => inum t1 i1 * total_num t2 + inum t2 i2
  | IUnionL t1 t2 i1 => inum t1 i1 + total_num t2
  | IUnionR t1 t2 i2 => inum t2 i2
  end.
\end{lstlisting}

\noindent This function then lets us define the key theorem needed for the
induction principle. At each step, the value of \c{inum} decreases by 1, and
since it cannot be negative, the iterator must therefore reach a final
state.

\begin{lemma}[Monotonicity]\label{inum_mono}
If $\c{next}~t~it = it'$ then $\c{inum}~t~it = 1 + \c{inum}~t~it'$.
\end{lemma}

\noindent
It is not possible to define an induction principle over \c{next}. By
monotonicy, \c{next} eventually reaches a final state.  For any property
of interest, if we prove that it holds of the final state and for the
induction step, we can prove it holds for every state for that type.

\begin{theorem}[Tree Iterator Induction]\label{indprop}
Let $P$ be any property of tree iterators for some type $t$.  Suppose $P$
holds of the final state, and whenever $P$ holds of a successor state $it$
then it holds of its precursor $it'$ where $\c{next}~t~it' = it$.  Then $P$
holds of every iterator state over $t$.
\end{theorem} 

\noindent
Now, one can prove correctness of the subtyping algorithm with tree
iterators.  A version of \c{sub} which uses tree iterators instead of choice
strings is required.  This implementation walks type terms and the iterator
state simultaneously. However, as the tree iterators are linked to the
specific structure of the type (unlike choice strings), we must break down
the iterator at every level encountered even if no union is present.

\begin{lstlisting}
Fixpoint sub(a b:Typ)(i:iter a)(i':iter b) :=
    match (a, b, i, i') with
    | (Prim(p), Prim(p'), IPrim _, IPrim _) => p == p'
    | (Tuple a a', Tuple b b', ITuple _ _ ia ia', ITuple _ _ ib ib') =>
        sub a b ia ib && sub a b ia' ib'
    | (Union a _, b, ILeft _ _ ia)   => sub a b ia i'
    | (Union _ a, b, IRight _ _ ia)  => sub a b ia i'
    | (a, Union b _, ia, ILeft _ _ ib)  => sub a b i ib
    | (a, Union _ b, ia, IRight _ _ ib)  => sub a b i ib
    | (_, _, _, _) => false
    end.
\end{lstlisting}

\noindent
Versions of \c{exist} and \c{allexist} that use tree iterators are given
next. They are similar to the string iterator functions of Section~\ref{cs}.
\c{exist} tests if the subtyping relation holds in the context of the
current iterator states for both sides. If not, it recurs on the next
state. Similarly, \c{allexist} uses its iterator for $a$ in conjunction with
\c{exist} to ensure that the current left hand iterator state has a matching
right hand state. We prove termination of both using Lemma~\ref{inum_mono}.

\begin{lstlisting}
Definition subtype(a b:Typ) = allexist a b (initial a)

Program Fixpoint allexist (a b:typ)(ia:iter a) {measure(inum ia)} =
   exists a b ia (initial b) && 
      (match next a ia with 
       | Some(ia') => allexist a b ia' 
       | None => true).

Program Fixpoint exist(a b:typ)(ia:iter a)(ib:iter b)
                                      {measure(inum ib)} =
   subtype a b ia ib  || 
      (match next b ib with 
       | Some(ib') => exist a b ia ib' 
       | None => false).
\end{lstlisting}

\newcommand{\irdn}[1]{\ensuremath{\mathcal{R}({#1})}}
\newcommand{\irch}[2]{\ensuremath{|#1|_{#2}}}

\noindent
The denotation of a tree iterator state $\irdn{i}$ is the set of states that
can be reached using \c{next} from $i$. Let $a(i)$ indicate the union-free
type produced from the type $a$ at $i$, and \irch{i}{a} is the set
$\{a(i')\,|\,i'\in\irdn{i}\}$, the union-free types that result from states
in the type $a$ reachable by $i$.  This lets us prove that the set of types
corresponding to states reachable from the initial state of an iterator is
equal to the set of states denoted by the type itself.

\begin{lemma}[Initial equivalence]\label{triter_eq}
$\irch{\c{initial}~a}{a} = \denotes{a}$.
\end{lemma}

\noindent
Next, Theorem~\ref{indprop} allows us to show that \c{exists} of $a$, $b$,
with $i_a$ and $i_b$ will try to find an iterator state $i_b'$ starting from
$i_b$ such that $b(i_b') = a(i_a)$. The desired property trivially holds
when $\irch{i_b}{b} = \emptyset$, and if the iterator can step then either
the current union-free type is satisfying or we defer to the induction
hypothesis.


\begin{theorem}\label{trexcor}
$\c{exist}\,a\,b\,i_a\,i_b$ holds iff $\exists t\in\irch{i_b}{b},a(i_a)= t$.
\end{theorem}

\noindent
We can then appeal to both Theorem~\ref{trexcor} and Lemma~\ref{triter_eq}
to show that $\c{exist}\,a\,b\,i_a\,(\c{initial}\,b)$ will find a satisfying
union-free type on the right hand side if it exists in $\denotes{b}$. Using
this, we can then use Theorem~\ref{indprop} in an analogous way to \c{exist}
to show that \c{allexist} is correct up to the current iterator state.

\begin{theorem}\label{trfacor}
$\c{allexist}\,a\,b\,i_a$ holds iff $\forall a'\in \irch{i_a}{a},
  \exists b'\in \denotes{b}, a'= b'$.
\end{theorem}

\noindent
Finally, we can appeal to Theorem~\ref{trfacor} and Lemma~\ref{triter_eq}
again to show the subtyping algorithm to be correct.

\begin{theorem}\label{trsub}
$\c{subtype}\,a\,b$ holds iff $\forall a' \in \denotes{a}, \exists b' \in
  \denotes{b}, a' = b'$.
\end{theorem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Subtyping with Choice Strings}

We prove the subtyping algorithm using choice strings by showing that string
iterators simulate tree iterators.  To relate tree iterators to choice
string iterators, we use the \c{itp} function, which traverses a tree
iterator state and produces a choice string using a depth-first search.

\newpage
\begin{lstlisting}
Fixpoint itp{t:Typ}(it:iter t):choice list :=
   match it with
   | IPrim _ => nil
   | ITuple t1 t2 it1 it2 => (itp t1 it1)++(itp t2 it2)
   | ILeft t1 _ it1 => Left::(itp t1 it1)
   | IRight _ t2 it1 => Right::(itp t2 it1)
   end.
\end{lstlisting}

\noindent
Next, in order to show that the choice string iteration order is exhibited
when linearizing tree iterators into choice strings.  The \c{next} function
in Section~\ref{cs} worked by finding the last \L in the choice string,
turning it into an \R, and replacing the rest with \Ls until the type was
valid. If we use \c{itp} to translate both the initial and final states for a valid
\c{next} step of a tree iterator, we see the same structure.

\begin{lemma}[Linearized Iteration]
\label{lem:snt}
For some type $t$ and tree iterators $\mathit{it}\,\mathit{it}'$, if
$\c{next}\,t\,\mathit{it}=\mathit{it'}$, there exists some prefix  $c'$, an
initial suffix $c''$ made up of \Rs, and a final suffix  $c'''$
consisting of \Ls such that $\c{itp}~t~it=c'\,\c{Left}\,c''$ and 
$\c{itp}~t~it'=c'\,\c{Right}\,c'''$.
\end{lemma}

\noindent
We can then prove that stepping a tree iterator state is equivalent to
stepping the linearized versions of the state using the choice string
\c{next} function.

\begin{lemma}[Step Equivalence]\label{sctxcorr}
If $\mathit{it}$ and $\mathit{it'}$ are tree iterator states and
$\c{next}~\mathit{it}=\mathit{it}'$, then $\c{next} (\c{itp}\;\mathit{it}) =
(\c{itp}\;\mathit{it'})$.
\end{lemma}
\noindent
Finally, the initial state of a tree iterator linearizes to the
initial state of a choice string iterator.

\begin{lemma}[Initial Equivalence]\label{eqinit}
$\c{itp} (\c{initial}\;t) = \c{pad}\;t\;\c{[]}$.
\end{lemma}

\noindent
The functions \verb|exist| and \verb|allexist| for choice string based
iterators are identical to those for tree iterators (though using choice
string iterators internally), and \verb|sub| is as described in
Section~\ref{cs}. The proofs of correctness for the choice string subtype
decision functions use the tree iterator induction principle
(Theorem~\ref{indprop}), and are thus in terms of tree iterators. By
Lemma~\ref{sctxcorr}, however, each step that the tree iterator takes will be
mirrored precisely \c{itp} into choice strings. Similarly, the initial states
are identical by Lemma~\ref{eqinit}. As a result, the sequence of states
checked by each of the iterators is equivalent with \c{itp}.

\begin{lemma}\label{cstrec}
$\c{exist}~a~b~(\c{itp}~i_a) (\c{itp}~i_b)$ holds iff $\exists t \in
  \irch{i_b}{b}, a(ia)=t$.
\end{lemma}

With the correctness of \c{exist} following from the tree iterator definition,
we can apply the same proof methodology to show that \c{allexist} is correct
when over translated tree iterators. In order to do so, we instantiate
Lemma~\ref{cstrec}  with Lemma~\ref{triter_eq} and Lemma~\ref{eqinit} to show
that if $\c{exist}\;\c a\;\c b\;(\c{itp}\;\c{ia})\;(\c{pad}\;\c t\;\c{[]})$
then $\exists \c t \in \denotes{\c b}, \c a(\c{ia}) = \c t$, allowing us to check 
each of the exists cases while establishing the forall-exists relationship.

\begin{lemma}\label{cstraec}
$\c{allexist}~a~b (\c{itp}~i_a)$
 holds iff $\forall a'\in\irch{i_a}{a}, \exists b'\in\denotes{b},a'=b'$.
\end{lemma}

\noindent We can then instantiate Lemma~\ref{cstraec} with
Lemma~\ref{eqinit} and Lemma~\ref{triter_eq} to show that \c{allexist} for
choice strings ensures that the forall-exists relation holds.
 
\begin{theorem}
$\c{allexist}~a~b~(\c{pad}~t~\c{[]})$
 holds iff $\forall a'\in\denotes{a},\exists b'\in\denotes{b}, a'=b'$.
\end{theorem}

\noindent Finally, we can prove that subtyping is correct using the choice
string algorithm.

\begin{theorem}\label{trsub}
$\c{subtype}~a~b$ holds iff $\forall a'\in\denotes{a}, \exists
  b'\in\denotes{b}, a'=b'$.
\end{theorem}

\noindent
Thus, we can correctly decide subtyping with distributive unions and tuples
using the choice list based implementation of iterators.

\section{Complexity}

Worst case time complexity of Julia's subtyping algorithm and
normalization-based approaches is determined by the number of terms that
would exist in the normalized type. In the worst case, there are $2^n$
union-free tuples in the fully normalized version of a type that has $n$
unions.  Each of these tuples must always be explored. As a result, both
algorithms have worst-case $O(2^n)$ time complexity. The approaches differ,
however, in space complexity. The normalization approach computes and stores
each of the exponentially many alternatives, so also has $O(2^n)$ space
complexity. However, Julia need only store the choice made at each union,
thereby offering $O(n)$ space complexity.

Julia's algorithm improves best-case time performance.  Normalization always
experiences worst case time and space behavior as it has to precompute the
entire normalized type. Julia's iteration-based algorithm can discover the
relation between types early. In practice, many queries are of the form
$\mathit{uft} <: union(t_1...t_n)$ where $\mathit{uft}$ is an already
union-free tuple. As a result, all that Julia needs to do is find one matching
tuple in $t_1 ... t_n$, which could be handled quickly by a fast path.

\section{Conclusion}

We have described and proven correct a subtyping algorithm for covariant
tuples and unions that use iterators instead of normalization.  This
algorithm is able to decide subtyping in the presence of distributive
semantics for union over tuples.

Future work is to handle some additional features of the Julia language.
Our next steps will be subtyping for primitive tpyes, existential type
variables, and invariant constructors.  Adding a subtyping to primitive
types would be the simplest change. The challenge is how to retain
completeness, as a primitive subtype heirarchy and semantic subtyping have
undesirable interactions.  For example, if the primitive subtype hierarchy
contains only the relations $p_2 \sub p_1$ and $p_3 \sub p_1$, then is
$p_1$ a subtype of $\union{p_2}{p_3}$? In a semantic subtyping system, they
are, but this requires changes both to the denotational framework and the
search space of the iterators.  Existential type variables create
substantial new complexities in the state of the algorithm. No longer is the
state solely restricted to that of the iterators being attempted; now, the
state includes variable bounds that are accumulated as the algorithm
compares types to type variables. As a result, correctness becomes a much
more complex contextually-linked property to prove.  Finally, invariant type
constructors induce contravariant subtyping, which in the context of
existential type variables has the potential to create cycles within the
subtyping relation. As a consequence, the termination of our algorithm comes
into question even if the language is otherwise limited to avoid provable
non-termination.

\medskip

\subsubsection*{Acknowledgments}
The authors thank Jiahao Chen for starting us down the path of understanding
Julia, and Jeff Bezanson for coming up with Julia's subtyping algorithm.  This
work received funding from the European Research Council under the European
Union's Horizon 2020 research and innovation programme (grant agreement
695412), the NSF (award 1544542 and award 1518844) and the Czech Ministry of
Education, Youth and Sports (grant agreement
CZ.02.1.01/0.0/0.0/15\_003/0000421).
 

%\bibliographystyle{plain}
\bibliography{refs}
\end{document}
