\documentclass[a4paper,english]{lipics-v2018}
\usepackage{microtype,amssymb,amsmath,stmaryrd,mathpartir,array,graphicx}%if unwanted, comment out or use option "draft"
\usepackage[table]{xcolor}
\newcommand{\xt}[1]{\texttt{#1}}
\newcommand{\tupleo}[1]{\xt{Tuple1\{}#1\xt{\}}}
\newcommand{\tuplet}[2]{\xt{Tuple2\{}#1,#2\xt{\}}}
\newcommand{\union}[2]{\xt{Union\{}#1,#2\xt{\}}}
\newcommand{\denotes}[1]{\llbracket #1 \rrbracket}

%FZ
\newcommand{\sub}{<:}
\newcommand{\tuple}[1]{\xt{Tuple\{}#1\xt{\}}}
\newcommand{\arrayt}[1]{\xt{Array\{}#1\xt{\}}}
%end FZ

\newcommand{\bsub}{<:_b}
\newcommand{\nsub}{<:_n}

\newcommand{\goodcell}{\cellcolor{green!25}}
\newcommand{\badcell}{\cellcolor{red!25}}

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the recommnded bibstyle

\title{On Julia's efficient algorithm for subtyping union types and covariant tuples (Pearl)}

%\titlerunning{Temporary Title}%optional, please use if title is longer than one line

\author{Anon}{None}{}{}{}

%\author{Benjamin Chung}{Northeastern University}{bchung@ccs.neu.edu}{}{}%mandato
%\author{Francesco Zappa Nardelli}{Inria}{}{}{}
%\author{Jan Vitek}{Northeastern University \& Czech Technical University}{}{}{}

\authorrunning{Anon}%B. Chung, F. Zappa Nardelli, J. Vitek}%mandatory. First: Use abb

\Copyright{Anon}%Benjamin Chung, Francesco Zappa Nardelli, Jan Vitek}%mandatory, plea

\subjclass{Dummy classification}% mandatory: Please choose ACM 2012 classifications from https://www.acm.org/publications/class-2012 or https://dl.acm.org/ccs/ccs_flat.cfm . E.g., cite as "General and reference $\rightarrow$ General literature" or \ccsdesc[100]{General and reference~General literature}. 

\keywords{Type systems, Subtyping, Union types}

\category{}%optional, e.g. invited paper

\relatedversion{}%optional, e.g. full version hosted on arXiv, HAL, or other respository/website

\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...

\funding{}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

% put the algorithm up front and explanation
% here's a cute and simple algorithm that works for distributive tuples and unions
% write it with imperative stacks
% tuple union is hard known for 20yrs sol w/ normalization
% prob 1: state explosion (also seen in swift) CDeuce approach doesn't work
% prob 2: expressivity interacting with rhicher type system normalization doesn't work at all
% what we show is an alternative way to deal with distributive subtyping
% sol prob 1: lazy stack-based subtyping algorithm
% sol prob 2: ....
%
\acknowledgements{}%optional

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%\nolinenumbers %uncomment to disable line numbering
%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle
\begin{abstract}
  We describe the clever algorithm implemented in the Julia
  programming language runtime to decide subtype on a simple type
  system with union types, covariant tuples, and literals.  This
  algorithm is immune from the space-explosion and expressiveness
  problems of the standard algorithms based on normalising types in
  disjuntcive normal form ahead-of-time.  We additionally prove it
  correct and complete against a semantic-subtyping denotational model
  in Coq.
\end{abstract}

\section{Subtyping union types and covariant tuples}

Union types are increasingly common in mainstream languages.
In some cases, as Julia~\cite{BezansonEKS17} or TypeScript~\cite{},
they are exposed at the source level. In others, as Hack~\cite{}, they
are only used internally when performing type inference; in all cases
they play a key role in the expressiveness of the language.

Rules for subtyping union types have been known for a long time.  Following Vouillon~\cite{Vouillon04} they may be written as:
\begin{mathpar}
\inferrule{t_1 \sub t \\ t_2 \sub t}{\union{t_1}{t_2} \sub t}

\quad

\inferrule{t \sub t_1}{t \sub \union{t_1}{t_2}}

\inferrule{t \sub t_2}{t \sub \union{t_1}{t_2}}
\end{mathpar}
These rules are asymmetrical. Following from set-theoretic intuitions,
and as made formal by semantic subtyping models, when a union type
appears on the left-hand side of a subtype judgment, then \emph{all}
its component must be subtypes of the right-hand side; whan a union
type appears on the right-hand side of a subtype judgment, then there
must \emph{exist} one of its component that is a supertype of the
left-hand side.

It has also been known for a long time that, in presence of covariant
tuples, the above rules are not complete with respect to a semantic
subtyping model~\cite{}. Let us
recall the subtype rule for covariant tuples:
\[
\inferrule{t_1 \sub t'_1 \\ t_2 \sub t'_2}{\tuple{t_1, t_2} \sub \tuple{t'_1, t'_2}}
\]
In a semantic subtyping model, covariant types should be
\emph{distributive} with respect to unions, that is the following (and
the opposite)
derivation should hold:
\[
\tuple{\union{t_1}{t_2}, t} \ \ \sub\ \ \union{\tuple{t_1, t}}{\tuple{t_2, t}} 
\]
Here the rule for tuples cannot be applied, and a derivation must
immediately solve the exist query for union types, picking either the
first or second component of the union type; as a result, it is
impossible to complete the derivation.  The standard approach to solve
this conundrum is to \emph{rewrite all types into their disjunctive
  normal form} (DNF), that is as unions of union-free types,
\emph{before} building the derivation. The correctness of this
rewriting step is justified by the semantic-subtyping denotational
model, as in~\cite{Frisch08}, and the resulting subtype algorithm can be proved both
correct and complete.  However, this standard algorithm based on
ahead-of-time normalization has \emph{two major drawbacks}.  The first
drawback is that the normalization phase rewrites types into
potentially \emph{exponentially bigger} types.
This is a problem in practice.  Previous work~\cite{} instrumented
Julia's subtype decision procedure and when executing library code,
routinely observed queries involving types as the one below:
\begin{small}
\begin{verbatim}
 Tuple{Tuple{Union{Int64, Bool}, Union{String, Bool}, Union{String, Bool}, 
             Union{String, Bool}, Union{Int64, Bool}, Union{String, Bool}, 
             Union{String, Bool}, Union{String, Bool}, Union{String, Bool}, 
             Union{String, Bool}, Union{String, Bool}, Union{String, Bool}, 
             Union{String, Bool}, Union{String, Bool}, Union{String, Bool}}, Int64}
\end{verbatim}
\end{small}
Normalizing this type before attempting to decide subtyping is not a
realistic option.  However such types are often matched against
structurally simpler types as
\begin{small}
\begin{verbatim}
 Tuple{Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any}, 
       Any}
\end{verbatim}
\end{small}
(where in Julia \verb+Any+ is the supertype of all types); in these cases
without ahead-of-time normalisation it is possible to decide subtyping
in linear time.

The second drawback of ahead-of-time normalisation phase is that it
does not interact nicely with other type system features. For instance
\emph{invariant constructors} make lifting all union types to the top
level unsound.
Consider the type \(\arrayt{\union{t_1}{t_2}}\), where \texttt{Array}
is an invariant unary constructor.  This type
denotes the set of arrays whose elements are either of type \(t_1\) or
\(t_2\): it would be incorrect to rewrite it as
\(\union{\arrayt{t_1}}{\arrayt{t_2}}\),
as this latter type denotes the set of arrays
whose elements are either all of type \(t_1\) or all of type
\(t_2\).  A weaker disjunctive normal form, only lifting union types inside
each invariant constructor, can circumvent this
problem, but only to reveal a deeper problem in the presence of
 both invariant constructors and \emph{existential types}.
Consider the judgment below:
\[
  \arrayt{\union{\tuple{t_1}}{\tuple{t_2}}} \ \ <:\ \ \exists T\,.\, \arrayt{\tuple{T}}
\]
This judgment holds by taking \(T = \union{t_1}{t_2}\).  Since all
types are in weak normal form, a standard algorithm would initially
perform the left-to-right subtype check due to the outer invariant
constructor.  This step would generate the constraint \(T >:
\union{t_1}{t_2}\).  As a consequence, the subsequent right-to-left
check due to the invariant constructor fails.  Indeed this requires
proving that \(\tuple{T} <: \union{\tuple{t_1}\tuple{t_2}}\), which
in turns attempts to prove either \(T <: t_1\) or \(T <: t_2\),
both unprovable under the assumption that \(T >: \union{t_1}{t_2}\)
The key to derive a successful judgment for this relation is to rewrite the
right-to-left check into \(\tuple{T} <: \tuple{\union{t_1}{t_2}}\),
which is provable. This is a sort of \emph{anti-normalisation} rewriting, that
must be performed on sub-judgments of the derivation, and to the best
of our knowledge it is not part
of any subtype algorithm based on ahead-of-time disjunctive normalisation.


%% FZN : Duplicate of text already written
%% FZN : fix citations above though.
%%
%% Previous efforts to provide a decision procedure for distributive unions rely
%% heavily on normalization. In order to decide subtyping in one of these
%% approaches, the type is first normalized (to integrate the distributivity
%% axiom) and then the standard syntax-directed subtyping algorithm is applied to
%% conclude the subtyping
%% relation~\cite{muehlboeck2018empowering,Reynolds1997,Pierce1991}. This
%% normalization step puts the type into disjunctive normal form thereby allowing
%% the algorithmic union rule to decide subtyping correctly. As there are
%% exponentially many choice sets for any given type (where one of two choices
%% may be given at each union), the space taken up by the fully normalized type
%% can be substantial. Moreover, (in languages with some kind of higher-rank
%% polymorphism) the normalization process eliminates all internal unions; as a
%% concequence, variable instantiations may be over-specialized and some
%% semantically-valid subtyping relations may not hold.

In this \emph{pearl paper} we describe the keys ideas used by the
subtype algorithm implemented in the Julia language to deal with
union types and covariant tuples, and we will argue that these avoid the
two drawbacks above.  To avoid being drawn in the vast complexity of
Julia type algebra, we focus on a minimal language featuring union
types, covariant tuples, and literals.  This tiny language is
expressive enough to highlight the decision strategy, and make this
implementation technique known to a wider audience.  While Julia
implementation shows that this technique extends, among others, to
invariant constructors and existential
types~\cite{DBLP:journals/pacmpl/NardelliBPCBV18}, we expect that it
can be leveraged in many other modern language designs.  Additionally
we prove in Coq that the algorithm is correct and complete with
respect to a standard semantics subtyping model.


\section{A space-efficient algorithm}

The greatest difficulty of subtyping union types is to ensure that all of
the search space due to the union types forall/exist quantifications
is explored.  We have seen that the syntax-directed rules, if not
coupled with an ahead-of-time normalisation phase, do not ensure
completeness of the search in presence of covariant tuples.

The algorithm we propose for deciding subtyping works by iterating through every possible
choice that could be made between at branches of unions within the two types
participating in a subtype check. In this section, we will describe the
implementation of the algorithm in OCaml and will present our proof of
correctness in the following section.

The type language for our algorithm is a subset of that used in the Julia
programming language, removing type variables. So as to avoid needing an
additional externally-provided subtype hierarchy, we specify that atomic types
(atoms) are subtypes only if they are exactly the same.

\hspace{1em}

\begin{figure}
\center
\begin{tabular}{cc|cc|c}
\multicolumn{2}{c}{Stack} & \multicolumn{2}{c}{Type} & Base Query \\
\hline
$\forall$ & $\exists$ & $\forall$ & $\exists$ & \\
\hline
\goodcell L & \goodcell L & \goodcell \includegraphics[scale=0.3]{figures-gen/left1.pdf} & \goodcell \includegraphics[scale=0.3]{figures-gen/right1.pdf} 
    & \goodcell ${A} <: {A}$ \\
\goodcell L & \badcell R & \badcell \includegraphics[scale=0.3]{figures-gen/left1.pdf} & \badcell \includegraphics[scale=0.3]{figures-gen/right2.pdf}  
    & \badcell ${A} \not<: {B}$ \\
\hline
\goodcell R & \badcell L & \badcell \includegraphics[scale=0.3]{figures-gen/left2.pdf} & \badcell \includegraphics[scale=0.3]{figures-gen/right1.pdf}  
    & \badcell ${B} \not<: {A}$ \\
\goodcell R & \goodcell R & \goodcell \includegraphics[scale=0.3]{figures-gen/left2.pdf} & \goodcell \includegraphics[scale=0.3]{figures-gen/right2.pdf}  
    & \goodcell ${B} <: {B}$ \\
\hline
\end{tabular}

\hspace{1em}

$\tupleo{\union{A}{B}} <: \union{\tupleo{A}}{\tupleo{B}}$

\caption{Subtyping decision procedure example}
\label{fig:cfs}
\end{figure}

\begin{minipage}{\textwidth}
\begin{minipage}{0.4\textwidth}
\begin{verbatim}
type typ =
  | Atom of int
  | Tuple1 of typ
  | Tuple2 of typ * typ
  | Union of typ * typ

type st_choice = Left | Right
\end{verbatim}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{verbatim}
let rec initial_choice (a:typ) =
  match a with
  | Atom i -> []
  | Tuple1 t -> initial_choice t
  | Tuple2(t1,t2) -> (initial_choice t1) 
  		@ (initial_choice t2)
  | Union(l,r) -> Left::(initial_choice l)
\end{verbatim}
\end{minipage}
\end{minipage}
\hspace{1em}

\noindent An example execution of the subtyping decision procedure is shown in
figure~\ref{fig:cfs}. Here, we are determining if $\tuple{\union{A}{B}} <:
\union{\tuple{A}}{\tuple{B}}$. To check if the relation holds, the algorithm
needs to ensure that for every instantiation on the left hand side that there
is an instantiation of the right hand side such that the basic subtyping
relation holds. In this case, the relation holds: no matter if we choose 
$\tuple{A}$ or $\tuple{B}$ on the left hand side, we can always pick the
same on the right hand side. Therefore, subtyping holds. The key challenge for
a subtyping algorithm for this type language, then, is providing it with the ability
to enumerate every possible instantiation of the left and right hand sides without
needing to normalize.

To do this, we base our approach on iterators. The key construct for our
algorithm is the \verb|st_choice| operation, which represents whether the
algorithm takes the left or the right branch of a union. The algorithm stores
the choice made at each union at the present iteration in two stacks of
\verb|st_choice|s, one for each side of the subtype relation.

A \verb|st_choice| stack can be seen as the state of an iterator that
enumerates every union-type induced alternative in a given type. It is
possible to define both an initial element and next state function for
iterators defined using \verb|st_choice| stacks. In turn, it is possible
to use \verb|st_choice| stacks to enumerate every possible choice that can
be made at union types within a program.

We choose the initial value for our iterators to be the state where, every
time a union type is encountered in the structure of the type, the iterator
takes the  leftmost choice (as implemented in \verb|initial_choice|). As the
iterator continues through the possible choices, it will successively move
right through the type until it reaches the state where at every  union type
it encounters it takes the right-hand choice.

\begin{figure}
\begin{tabular}{cccc}
& \hspace{5em} & &\\
\includegraphics[scale=0.6]{figures-gen/example1.pdf} &
\multicolumn{2}{c}{\includegraphics[scale=0.6]{figures-gen/example2.pdf}} &
\includegraphics[scale=0.6]{figures-gen/example3.pdf} \\
L & \multicolumn{2}{c}{R} & RL \\
\multicolumn{2}{c}{last\_left\_to\_right} & \multicolumn{2}{c}{extend\_list} \\
\hline
\multicolumn{4}{c}{next\_state} \\
\end{tabular}
\caption{State-stepping operation for choice lists}
\label{fig:sstep}
\end{figure}

\begin{verbatim}
let rec last_left_to_right 
    (acc:st_choice list) (ll : st_choice list option) = function
  | Left::tl -> last_left_to_right (Left::acc) (Some (Right::acc)) tl
  | Right::tl -> last_left_to_right (Right::acc) ll tl
  | [] -> option_map List.rev ll
\end{verbatim}

With a definition for the initial state, we can then define the iteration function.
We break the iteration function, \verb|next_state| up into two helper functions. The
operation of these helpers is illustrated in figure~\ref{fig:sstep}. Here, starting
from the initial state (where the iterator takes the leftmost choice at the root of
the type), \verb|last_left_to_right| converts the left choice into a right choice. However,
because this is not yet a complete selection through the type, \verb|extend_list| is then
used to appropriately pad out the type with left choices.

\verb|last_left_to_right| performs the incremental stepping-to-the-right operation at
state transitions. It finds the final left choice in a given choice stack, truncates the
stack to that left choice, and then converts it to a right. For example, given the type 
$\union{\union{A}{B}}{C}$ and the choice list LL, \verb|last_left_to_right| will 
produce the choice list LR; if given LR, it will produce R (as the final left choice
is at the top-level and it truncates the remainder of the choice list).

\begin{verbatim}
let rec extend_list (a:typ) (ls:st_choice list) = match (a,ls) with
  | (Atom i, _) -> ([], ls)
  | (Tuple1 t, _) -> extend_list t ls
  | (Tuple2(t1,t2), _) -> let (hd,tl) = extend_list t1 ls in
                          let (hd2,tl2) = extend_list t2 tl in
                          (hd @ hd2, tl2)
  | (Union(l,r), Left::rs) -> let (hd,tl) = extend_list l rs in (Left::hd,tl)
  | (Union(l,r), Right::rs) -> let (hd,tl) = extend_list r rs in (Right::hd,tl)
  | (Union(l,r), []) -> (Left::initial_choice l,[])
\end{verbatim}

On some types (such as that shown in figure~\ref{fig:sstep}), though, this
truncation leaves a partial path. \verb|extend_list| finds where the new
choice list runs out and fills it out to be valid with respect to the type
giving a valid state. If no successor state is found---if there are no Left
choices that remain---then the function will return None. In figure~\ref{fig:sstep},
\verb|last_left_to_right| produced a partial path, as the right child of the root
union is a union itself. \verb|extend_list| pads the list out to take the left choice
at this child union, returning the path to validity.

\begin{verbatim}
let rec next_state (a:typ) (ls:st_choice list) =
  option_map fst (option_map (extend_list a) (last_left_to_right [] None ls))
\end{verbatim}

\verb|next_state| combines these operations into a single step operation. It
will take the deepest alternative choice at a union using
\verb|last_left_to_right|, then add however many left choices is required to
make the path valid using \verb|extend_list|. 

Now that we have defined the core iterator infrastructure, we can show how it
is used to decide subtyping queries. The algorithm proceeds by maintaining two
iterators (one for each side of the subtyping judgment) over choices-at-
unions,  checking that for every instantiation of the left hand type there
exists an instantiation of the right hand type. We will first define the
fundamental subtyping relation, used to decide subtyping relationships when
given instantiations of the left and right hand types, then describe the
algorithm that iterates through those types.

\begin{verbatim}
type st_res =
  | Subtype of st_choice list * st_choice list
  | NotSubtype
\end{verbatim}

\verb|st_res| represents the results of a single base subtype query. The query
can either succeed, in which case it provides the unused portion of the input
stacks, or fail. 

\begin{verbatim}
let rec base_subtype (a:typ) (b:typ) (fa:st_choice list) (ex : st_choice list)
  match (a,b,fa,ex) with
  | (Atom i, Atom j, _, _) -> if i == j then Subtype(fa, ex) else NotSubtype
  | (Tuple1 t1, Tuple1 t2, _, _) -> base_subtype t1 t2 fa ex
  | (Tuple2(ta1, ta2), Tuple2(tb1, tb2), _, _) ->
     (match base_subtype ta1 tb1 fa ex with
      | Subtype(cfa, cex) -> base_subtype ta2 tb2 cfa cex
      | NotSubtype -> NotSubtype)
  | (Union(a1,a2),b,choice::fa,ex) -> 
  		base_subtype (match choice with Left -> a1 | Right -> a2) b fa ex
  | (a,Union(b1,b2),fa,choice::ex) -> 
  		base_subtype a (match choice with Left -> b1 | Right -> b2) fa ex
\end{verbatim}

\verb|base_subtype| is responsible for using two paths---one for the left and
right hand sides of the subtyping relation---and checking that the subtype
relation holds with respect to those paths. Given a basic type---an atom or a
tuple---it will either check equality or recur respectively. Given a union, it
will grab the choice to make at that union off of the choice stacks and continue
recursively. The function then returns an instance of \verb|st_res|, which
gives the remaining choice stacks if successful or nothing otherwise.


Finally, to check subtyping, we need to iterate through both types in the 
correct quantification order. Subtyping holds if, for every instantiation 
of the left there exists an instantiation of the right hand side of the
subtyping judgment such that the subtype relation holds. To check this,
we use a simple brute force approach sitting atop the choice stack iterator
infrastructure described previously. The algorithm is implemented in two
functions. \verb|ex_subtype| checks that there exists an instantiation
of the right-hand-side for a given left-hand-side. \verb|fa_ex_subtype|
uses \verb|ex_subtype| to check that for every instantiation of the LHS,
there is an instantiation of the RHS such that the subtype relation holds.

\begin{verbatim}
let rec ex_subtype (a:typ)(b:typ)(fa:st_choice list)(cex : st_choice list) =
  match base_subtype a b fa cex with (* is a <: b *)
  | Subtype(_,_) -> true (* there exists a subtype *)
  | NotSubtype -> 
     (match next_state b cex with (* step exists-env *)
      | Some ns -> ex_subtype a b fa ns (* continue *)
      | None -> false) (* no subtype; exit *)

\end{verbatim}

If the current choice --- given by \verb|cex| --- is a supertype of the given \verb|a| according
to \verb|base_subtype|, then \verb|ex_subtype| has found a valid instantiation of \verb|b|. Therefore,
there exists an instantiation of \verb|b| that is a supertype of \verb|a| and the result should be true.
Otherwise, \verb|ex_subtype| will use the iteration operation, \verb|next_state|, to continue iterating
through choices for \verb|b| until it either finds an instantiation that is a supertype or runs out
of instantiations.

\begin{verbatim}
let rec fa_ex_subtype (a:typ)(b:typ)(cfa:st_choice list) =
  match ex_subtype a b cfa (initial_choice b) with (* a <: b wrt path? *)
  | true -> (match next_state a cfa with
               | Some ns -> fa_ex_subtype a b ns (* continue *)
               | None -> true) (* all subtypes; is subtype *)
  | false -> false (* exists a non-subtype; not subtype *)
\end{verbatim}

\verb|fa_ex_subtype| is very similar. It checks that for every
instantiation of \verb|a|, there exists an instantiation of 
\verb|b| such that subtyping holds. Checking for an instantiation
of \verb|b| is done using \verb|ex_subtype|, while \verb|fa_ex_subtype|
maintains an iterator for \verb|a|.

\begin{verbatim}
let rec subtype (a:typ) (b:typ) = fa_ex_subtype a b (initial_choice a)
\end{verbatim}

Finally, \verb|subtype| checks if \verb|a| is a subtype of \verb|b|.
It seeds \verb|fa_ex_subtype| with the initial choice for \verb|a|'s
iterator, which then checks if for every instantiation of \verb|a|
there exists an instantiation of \verb|b| such that subtyping holds.

We have presented our subtyping algorithm using lists of choices. In practical
implementation, however, these lists of choices can be efficiently implemented
(without allocation) by means of bit sets. This is the approach taken in the Julia
implementation of this algorithm. With this optimization, memory linear in the
total number of unions in a type is needed to decide subtyping between two types;
no allocation besides that for the choice stacks is needed in the algorithm

\section{Proof}

To prove correctness of our algorithm, we begin by formally specifying
correctness for subtyping. We then show that three subtyping algorithms---
based on  normalization, structural iterators, and choice lists---are correct
with respect to this definition.

We base our definition of subtyping on a denotational semantics for types. 
We reduce types in the type language including unions to sets of types
in the type language without unions through a simple transformation. 

\begin{align*}
\denotes{\xt{A}} &= \{A\} \\
\denotes{\union{t_1}{t_2}} &= \denotes{t1} \cup \denotes{t2} \\
\denotes{\tupleo{t}} &= \{\tupleo{t'} | t' \in \denotes{t}\} \\
\denotes{\tuplet{t_1}{t_2}} &= \{\tuplet{t'_1}{t'_2} | t_1' \in \denotes{t_1},  t_2' \in \denotes{t_2'}\} \\
\end{align*}

Using this denotational semantics for types-with-unions, we can define
subtyping as $\denotes{t_1} \subseteq \denotes{t_2}$, then $t_1 <: t_2$.
Equivalently, we can state this as definition~\ref{dfn:scr}, which is canonicalized
in our Coq proof as the \verb|NormalSubtype| relation.

\begin{definition}[Subtyping Correctness]
A subtyping relation $<:$ is correct if $t_1 <: t_2$ iff $\forall t_1' \in \denotes{t_1},
\exists t_2' \in \denotes{t_2}, t_1 \bsub t_2$.
\label{dfn:scr}
\end{definition}

Proving a subtyping algorithm sound and complete is therefore equivalent to
producing a function of type \verb|forall t1 t2:type, {NormalSubtype t1 t2} + {~NormalSubtype t1 t2}|; that is, is able to decide whether two types are
subtypes or not.

\subsection{Iterators}

The iterator-based implementation is directly equivalent (as will be shown
later) to the choice-stack based implementation presented previously in OCaml.
However, it retains type structure information inside of the iterator state.

\begin{verbatim}
Inductive TypeIterator: type -> Set :=
| TIAtom : forall i, TypeIterator (atom i)
| TITuple1 : forall tp, TypeIterator tp -> TypeIterator (tuple1 tp)
| TITuple2 : forall t1 t2, TypeIterator t1 -> TypeIterator t2 -> TypeIterator (tuple2 t1 t2)
| TIUnionL : forall t1 t2, TypeIterator t1 -> TypeIterator (union t1 t2)
| TIUnionR : forall t1 t2, TypeIterator t2 -> TypeIterator (union t1 t2).
\end{verbatim}

The \verb|TypeIterator| structure follows the structure of the type being
iterated over. Choices at unions are represented as either an instance of
\verb|TIUnionR| or \verb|TIUnionL|. This structure then lets us trivially
define a function that extracts the current type at the iterator's position:

\begin{verbatim}
Fixpoint current (t:type)(ti:TypeIterator t):type :=
match ti with
| TIAtom i => atom i
| TITuple1 tip p => tuple1 (current tip p)
| TITuple2 ti1 ti2 p1 p2 => tuple2 (current ti1 p1) (current ti2 p2)
| TIUnionL ti1 ti2 pl => (current ti1 pl)
| TIUnionR ti1 ti2 pr => (current ti2 pr)
end.
\end{verbatim}

Next, we can define a function that produces the initial iterator state for a
given type:

\begin{verbatim}
Fixpoint start_iterator (t:type):TypeIterator t :=
  match t with
  | (atom i) => TIAtom i
  | (tuple1 t) => TITuple1 t (start_iterator t)
  | (tuple2 t1 t2) => TITuple2 t1 t2 (start_iterator t1) (start_iterator t2)
  | (union t1 t2) => TIUnionL t1 t2 (start_iterator t1)
  end.
\end{verbatim}

Next, we can define a step function that takes one state and either steps it
to the next state or indicates that no such next state exists.

\begin{verbatim}
Fixpoint next_state (t:type)(ti:TypeIterator t) : option (TypeIterator t) :=
  match ti with
  | TIAtom i => None
  | TITuple1 tip p => option_map (TITuple1 tip) (next_state tip p)
  | TITuple2 ti1 ti2 p1 p2 =>
    match (next_state ti2 p2) with
    | Some np2 => Some(TITuple2 ti1 ti2 p1 np2)
    | None =>
      match (next_state ti1 p1) with
      | Some np1 => Some(TITuple2 ti1 ti2 np1 (start_iterator ti2))
      | None => None
      end
    end
  | TIUnionL ti1 ti2 pl =>
    match (next_state ti1 pl) with
    | Some npl => Some(TIUnionL ti1 ti2 npl)
    | None => Some(TIUnionR ti1 ti2 (start_iterator ti2))
    end
  | TIUnionR ti1 ti2 pr => option_map (TIUnionR ti1 ti2) (next_state ti2 pr)
  end.
\end{verbatim}

With these definitions, we can then prove a basic form of correctness with
respect to the denotational or normalization semantics:

\begin{theorem}[Correctness of iterators]
Every type in $\denotes{t}$ will be explored using \verb|next_step| from \verb|start_iterator t| 
\end{theorem}
\begin{proof}
See \verb|iterator_has_clauses| in the Coq proof.
\end{proof}

\verb|next_state| returns \verb|Some s| if there is some successor state
\verb|s| to the current, and \verb|None| if the given iterator state is
terminal. It will go left-to-right through unions, and will explore 2-tuples
by iterating through the choices on the right for each choice on the left. We can
then define an induction principle for type iterators based on \verb|next_state|:

\begin{theorem}
\begin{verbatim}
Definition iter_rect
  (t:type) (P:TypeIterator t -> Set)
           (pi: forall it, next_state t it = None -> P it)
           (ps : forall it' it'', P it'' -> next_state t it' = Some it'' -> P it')
           (it : TypeIterator t) : P it  
\end{verbatim}

For any type \verb|t| and proposition \verb|P|, and if:
\begin{itemize} 
	\item \verb|P| holds for an iterator that has no next state (e.g. is done)
	\item if \verb|P| holds for the \emph{following} iterator state \verb|it|,
	then \verb|P| holds for the \emph{preceeding} iterator state \verb|it'|.
\end{itemize}
Then \verb|P| holds for all iterators for type \verb|t|
\end{theorem}
\begin{proof}
See the Coq definition of \verb|iter_rect|.
\end{proof}

Using \verb|iter_rect|, we can implement and prove correct equivalent functions
to \verb|ex_subtype|, \verb|fa_ex_subtype|, and \verb|subtype| as described in the
OCaml implementation.

\begin{verbatim}
Definition exists_iter(a b : type) : 
  ({ t | InType t b /\ BaseSubtype a t } +
   {forall t, InType t b -> ~(BaseSubtype a t) }).
\end{verbatim}

\verb|exists_iter| is equivalent to the choice-stack based \verb|ex_subtype|,
and determines if there exists some denotationally-contained type in \verb|b|
that is a supertype of the given \verb|a|. Internally, it is implemented in 
the same way as \verb|ex_subtype|, though using \verb|iter_rect| to iterate 
through every iterator state.

\begin{verbatim}
Definition forall_iter (a b : type) :
  { forall t, In t (clauses a) -> exists t', InType t' b /\ (BaseSubtype t t')} +
  { exists t, In t (clauses a) /\ forall t', InType t' b -> ~ (BaseSubtype t t')}.
\end{verbatim}

\verb|forall_iter| is to \verb|fa_ex_subtype| what \verb|exists_iter| is to
\verb|ex_subtype|. Like \verb|exists_iter| it implements the same decision procedure
as \verb|fa_ex_subtype| (and internally relies upon \verb|exists_iter|), though through
the abstraction of \verb|iter_rect|.

Finally, we can define a decidable function (called \verb|subtype| in the proof)
that decides whether two types are subtypes or not. \verb|subtype| simply invokes
\verb|forall_iter| to decide subtyping.

\begin{verbatim}
Definition subtype(a b:type) : {NormalSubtype a b} + {~NormalSubtype a b}.
  destruct (forall_iter a b).
  - left. [...]
  - right. [...]
Defined.
\end{verbatim}

Therefore, using iterators, we can decide whether subtyping holds for any two types
in our language. We will now show an equivalence between iterators and stacks-of-choices,
allowing for more efficient implementation.

\subsection{Stacks}

To show that the choice-stack based algorithm is correct, we reduce it to the
already-shown-correct iterator-based algorithm for deciding subtyping. To do so,
we show an equivalence between choice stacks and iterators, then prove correctness
of the subtyping algorithms.

In the context of the Coq proof, we use the type \verb|st_context| to refer
to a choice stack. In Coq, this is represented as a list of boolean values,
with false representing a left choice and true representing a right choice at
a specific union.

To show equivalence between the iterator-based and stack-based algorithm, we need to
first prove two properties:

\begin{itemize}
  \item iterators are convertible to equivalent choice lists;
  \item stepping an iterator is equivalent to stepping a choice list.
\end{itemize}

We define an iterator and a choice stack to be equivalent if, when applied to
the same type, they select the same subset of that type. To describe this, we
define \verb|lookup_path| which looks up what type is selected by a given
choice stack.

\begin{verbatim}
Fixpoint lookup_path(t:type)(p:st_context) : type * st_context :=
  match t, p with
  | atom i, _ => (t, p)
  | tuple1 t, _ => let (r,p) := lookup_path t p in (tuple1 r, p)
  | tuple2 t1 t2, _ =>
    let (r1,p1) := lookup_path t1 p in
    let (r2,p2) := lookup_path t2 p1 in
    (tuple2 r1 r2, p2)
  | union l r, false::rs => lookup_path l rs
  | union l r, true::rs => lookup_path r rs
  | _, nil => (t, nil)
  end.
\end{verbatim}

\verb|lookup_path| is notable in that it both returns the selected type as
well as whatever of the choice stack remains once it reaches a leaf. This is
needed in order to be able to traverse types that contain tuples,  whose left
branches will potentially be given a longer choice stack then necessary.

Next, we can convert iterators to paths in the straightforward manner, as
implemented by \verb|iterator_to_path|:

\begin{verbatim}
Fixpoint iterator_to_path(t:type)(it:TypeIterator t):st_context :=
   match it with
   | TIAtom _ => nil
   | TITuple1 tp it1 => iterator_to_path tp it1
   | TITuple2 t1 t2 it1 it2 => (iterator_to_path t1 it1) ++ (iterator_to_path t2 it2)
   | TIUnionL t1 _ it1 => false :: (iterator_to_path t1 it1)
   | TIUnionR _ t2 it1 => true :: (iterator_to_path t2 it1)
   end.
\end{verbatim}

\verb|iterator_to_path| simply traverses the iterator in order, appending onto the
output choice stack whatever choice the iterator makes at that union. This illustrates
the equivalence between iterators and choice stacks; choice stacks are simply iterators
with the structural information removed.

Using the combination of \verb|lookup_path| and \verb|iterator_to_path|, we
can then show the first correctness property that we need to prove that the
algorithm using choice stacks is correct:

\begin{lemma}[Iterator to path is correct]
\begin{verbatim}
Lemma itp_correct : forall t it, current t it = fst (lookup_path t (iterator_to_path t it)).
\end{verbatim}

For every type \verb|t| and type iterator \verb|it|, the iterator's current type \verb|current t it| is equal
to the result of looking up the conversion of \verb|it| to a choice stack.
\end{lemma}
\begin{proof}
See \verb|itp_correct| in the Coq proof.
\end{proof}

Stepping in the Coq implementation is implemented identically to the OCaml
implementation. It only remains to show that this step operation (called
\verb|step_ctx| in Coq) is correct with respect to the iterator
\verb|next_state|.

\begin{lemma}[Correctness of step\_ctx]
\begin{verbatim}
forall t it,
    step_ctx t (iterator_to_path t it) =
    (option_map (iterator_to_path t) (next_state t it)).
\end{verbatim}
For every type \verb|t| and type iterator \verb|it|,
stepping the choice-list equivalent of \verb|it| will
produce the same result as converting the result of stepping
\verb|it|.
\end{lemma}
\begin{proof}
See \verb|list_step_correct| in the Coq proof.
\end{proof}

Now, with the relevant properties proven, we can implement and prove correct
\verb|ex_subtype| and \verb|fa_ex_subtype| in Coq. The function names are the
same, as are the implementations up to the addition of a fuel parameter (which
is shown to be unnecessary). 

\begin{lemma}[Correctness of existential subtype checking with choice stacks]
\begin{verbatim}
forall a b it, 
  (exists pf, exists_iter_inner a b it = inleft pf) <->
   exists n, ex_subtype a b (iterator_to_path b it) n = Some true.
\end{verbatim}
For every two types \verb|a| and \verb|b|, the iterator-based algorithm
\verb|exists_iter_inner| will produce a proof that \verb|a| is a subtype
of \verb|b| if and only if there is an integer \verb|n| such that
 \verb|ex_subtype| given \verb|n| fuel runs producing true.
\end{lemma}
\begin{proof}
See \verb|ex_sub_corr_eq| in the Coq proof.
\end{proof}

\begin{lemma}[Correctness of forall-exists subtype checking with choice stacks]
\begin{verbatim}
forall a b it,
   (exists pf, forall_iter_inner a b it = left pf) <->
    exists n, fa_ex_subtype a b (iterator_to_path a it) n = Some true.
\end{verbatim}
For every two types \verb|a| and \verb|b|, the iterator-based algorithm
\verb|forall_iter_inner| will produce a proof that \verb|a| is a subtype
of \verb|b| if and only if there is an integer \verb|n| such that
 \verb|fa_ex_subtype| given \verb|n| fuel runs producing true.
\end{lemma}
\begin{proof}
See \verb|fa_sub_corr_eq| in the Coq proof.
\end{proof}

The choice stack-based algorithm therefore provably produces the same results
as the iterator-based algorithm. 

\section{Conclusion}

We have presented an algorithm for deciding subtyping relationships between
types that consist of atomic types, tuples, and unions. This algorithm is able
to decide subtyping relationships in the presence of distributive semantics
for union types without needing normalization (and therefore using linear
space) and without additionally constraining type system features.

%\bibliographystyle{plain}
\bibliography{refs}

\end{document}
