\documentclass[a4paper,english]{lipics-v2019}
\usepackage{microtype,amssymb,amsmath,stmaryrd,mathpartir,array,graphicx}%if unwanted, comment out or use option "draft"
\usepackage[table]{xcolor}
\newcommand{\xt}[1]{\texttt{#1}}
%\newcommand{\tupleo}[1]{\xt{Tuple1\{}#1\xt{\}}}
\newcommand{\tuplet}[2]{\xt{Tuple\{}#1,#2\xt{\}}}
\newcommand{\union}[2]{\xt{Union\{}#1,#2\xt{\}}}
\newcommand{\denotes}[1]{\llbracket #1 \rrbracket}

%FZ
\newcommand{\sub}{<:}
\newcommand{\tuple}[1]{\xt{Tuple\{}#1\xt{\}}}
\newcommand{\arrayt}[1]{\xt{Array\{}#1\xt{\}}}
\newcommand{\FZ}[1]{\textbf{FZ says: #1}}
%end FZ

\newcommand{\goodcell}{\cellcolor{green!25}}
\newcommand{\badcell}{\cellcolor{red!25}}

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the recommnded bibstyle

\title{On Julia's efficient algorithm for subtyping union types and covariant tuples (Pearl)}

%\titlerunning{Temporary Title}%optional, please use if title is longer than one line


\author{Anonymous Authors}{Anonymous Affiliation}{}{}{}
\authorrunning{Anonymous Authors}


%\author{Benjamin Chung}{Northeastern University}{bchung@ccs.neu.edu}{}{}%mandato
%\author{Francesco Zappa Nardelli}{Inria}{}{}{}
%\author{Jan Vitek}{Northeastern University \& Czech Technical University}{}{}{}

\authorrunning{Anon}%B. Chung, F. Zappa Nardelli, J. Vitek}%mandatory. First: Use abb

\Copyright{Anon}%Benjamin Chung, Francesco Zappa Nardelli, Jan Vitek}%mandatory, plea
\ccsdesc[500]{Theory of computation~Type theory}
% mandatory: Please choose ACM 2012 classifications from https://www.acm.org/publications/class-2012 or https://dl.acm.org/ccs/ccs_flat.cfm . E.g., cite as "General and reference $\rightarrow$ General literature" or \ccsdesc[100]{General and reference~General literature}. 

\keywords{Type systems, Subtyping, Union types}

\category{}%optional, e.g. invited paper

\relatedversion{}%optional, e.g. full version hosted on arXiv, HAL, or other respository/website

\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...

\hideLIPIcs

\funding{}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

% put the algorithm up front and explanation
% here's a cute and simple algorithm that works for distributive tuples and unions
% write it with imperative stacks
% tuple union is hard known for 20yrs sol w/ normalization
% prob 1: state explosion (also seen in swift) CDeuce approach doesn't work
% prob 2: expressivity interacting with rhicher type system normalization doesn't work at all
% what we show is an alternative way to deal with distributive subtyping
% sol prob 1: lazy stack-based subtyping algorithm
% sol prob 2: ....
%
\acknowledgements{}%optional
%\acknowledgements{Celeste Hollenbeck}

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%\nolinenumbers %uncomment to disable line numbering
%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle
\begin{abstract}
  We describe the algorithm implemented in the Julia
  programming language runtime to decide subtyping on a simple type
  system with union types, covariant tuples, and literals.  This
  algorithm is immune from the space-explosion and expressiveness
  problems of standard algorithms that normalise types into
  disjunctive normal form ahead-of-time.  We prove this algorithm
  correct and complete against a semantic-subtyping denotational model
  in Coq.
\end{abstract}

\section{Subtyping union types and covariant tuples}

Union types are increasingly common in mainstream languages.
In some cases, as Julia~\cite{BezansonEKS17} or TypeScript~\cite{hejlsberg},
they are exposed at the source level. In others, such as Hack~\cite{hack}, they
are only used internally when performing type inference. In all cases,
they play a key role in the expressiveness of the language.

Rules for subtyping union types have been known for a long time.  Following Vouillon~\cite{Vouillon04} they may be written as:
\begin{mathpar}
\inferrule{t_1 \sub t \\ t_2 \sub t}{\union{t_1}{t_2} \sub t}

\quad

\inferrule{t \sub t_1}{t \sub \union{t_1}{t_2}}

\inferrule{t \sub t_2}{t \sub \union{t_1}{t_2}}
\end{mathpar}
These rules are asymmetrical. Following from set-theoretic intuitions,
and as made formal by semantic subtyping models, when a union type
appears on the left-hand side of a subtype judgment, then \emph{all}
its components must be subtypes of the right-hand side; whan a union
type appears on the right-hand side of a subtype judgment, then there
must \emph{exist} a component that is a supertype of the
left-hand side.

It has also been known for a long time that, in the presence of covariant
tuples, the above rules are not complete with respect to a semantic
subtyping model~\cite{Pierce1991}. Let us
recall the subtype rule for covariant tuples:
\[
\inferrule{t_1 \sub t'_1 \\ t_2 \sub t'_2}{\tuple{t_1, t_2} \sub \tuple{t'_1, t'_2}}
\]
In a semantic subtyping model, covariant types should be
\emph{distributive} with respect to unions; that is, the following (and
the opposite)
derivation should hold:
\[
\tuple{\union{t_1}{t_2}, t} \ \ \sub\ \ \union{\tuple{t_1, t}}{\tuple{t_2, t}} 
\]
Here the rule for tuples cannot be applied, and a derivation must
immediately pick either the
first or second component of the union type; as a result, it is
impossible to complete the derivation.  The standard approach to solve
this conundrum is to \emph{rewrite all types into their disjunctive
  normal form} (DNF), that is as unions of union-free types,
\emph{before} building the derivation. The correctness of this
rewriting step is justified by the semantic-subtyping denotational
model, as in~\cite{Frisch08}, and the resulting subtype algorithm can be proved both
correct and complete.  However, this standard algorithm based on
ahead-of-time normalization has \emph{two major drawbacks}.

The first
drawback is that the normalization phase rewrites types into
potentially \emph{exponentially bigger} types.
This is a problem in practice.  Previous work~\cite{DBLP:NardelliBPCBV18} instrumented
Julia's subtype decision procedure and when executing library code,
routinely observed queries involving types as the one below:
\begin{small}
\begin{verbatim}
 Tuple{Tuple{Union{Int64, Bool}, Union{String, Bool}, Union{String, Bool}, 
             Union{String, Bool}, Union{Int64, Bool}, Union{String, Bool}, 
             Union{String, Bool}, Union{String, Bool}, Union{String, Bool}, 
             Union{String, Bool}, Union{String, Bool}, Union{String, Bool}, 
             Union{String, Bool}, Union{String, Bool}, Union{String, Bool}}, Int64}
\end{verbatim}
\end{small}
Normalizing this type before attempting to decide subtyping is not a
realistic option. In practice, such types are often matched against
structurally simpler types like
\begin{small}
\begin{verbatim}
 Tuple{Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any}, 
       Any}
\end{verbatim}
\end{small}
(where in Julia \verb+Any+ is the supertype of all types); in these cases,
it is possible to decide subtyping in linear time without ahead-of-time normalisation.

The second drawback of the ahead-of-time normalisation phase is that it
does not interact well with other type system features. For instance,
\emph{invariant constructors} make lifting all union types to the top
level unsound.
Consider the type \(\arrayt{\union{t_1}{t_2}}\), where \texttt{Array}
is an invariant unary constructor.  This type
denotes the set of arrays whose elements are either of type \(t_1\) or
\(t_2\); it would be incorrect to rewrite it as
\(\union{\arrayt{t_1}}{\arrayt{t_2}}\),
as this latter type denotes the set of arrays
whose elements are either all of type \(t_1\) or all of type
\(t_2\).  A weaker disjunctive normal form, only lifting union types inside
each invariant constructor, can circumvent this
problem. However, doing so only to reveals a deeper problem in the presence of
 both invariant constructors and \emph{existential types}.
Consider the judgment below:
\[
  \arrayt{\union{\tuple{t_1}}{\tuple{t_2}}} \ \ <:\ \ \exists T\,.\, \arrayt{\tuple{T}}
\]
This judgment holds by taking \(T = \union{t_1}{t_2}\).  Since all
types are in weak normal form, a standard algorithm would initially
perform the left-to-right subtype check due to the outer invariant
constructor.  This step would generate the constraint \(T >:
\union{t_1}{t_2}\).  As a consequence, the subsequent right-to-left
check due to the invariant constructor fails.  Indeed this requires
proving that \(\tuple{T} <: \union{\tuple{t_1}}{\tuple{t_2}}\), which
in turns attempts to prove either \(T <: t_1\) or \(T <: t_2\),
both unprovable under the assumption that \(T >: \union{t_1}{t_2}\)
The key to derive a successful judgment for this relation is to rewrite the
right-to-left check into \(\tuple{T} <: \tuple{\union{t_1}{t_2}}\),
which is provable. This is a sort of \emph{anti-normalisation} rewriting that
must be performed on sub-judgments of the derivation, and to the best
of our knowledge it is not part
of any subtype algorithm based on ahead-of-time disjunctive normalisation.


%% FZN : Duplicate of text already written
%% FZN : fix citations above though.
%%
%% Previous efforts to provide a decision procedure for distributive unions rely
%% heavily on normalization. In order to decide subtyping in one of these
%% approaches, the type is first normalized (to integrate the distributivity
%% axiom) and then the standard syntax-directed subtyping algorithm is applied to
%% conclude the subtyping
%% relation~\cite{muehlboeck2018empowering,Reynolds1997,Pierce1991}. This
%% normalization step puts the type into disjunctive normal form thereby allowing
%% the algorithmic union rule to decide subtyping correctly. As there are
%% exponentially many choice sets for any given type (where one of two choices
%% may be given at each union), the space taken up by the fully normalized type
%% can be substantial. Moreover, (in languages with some kind of higher-rank
%% polymorphism) the normalization process eliminates all internal unions; as a
%% concequence, variable instantiations may be over-specialized and some
%% semantically-valid subtyping relations may not hold.

In this \emph{pearl paper} we describe the keys ideas used by the
subtype algorithm implemented in the Julia language to deal with
union types and covariant tuples, and we will argue that these avoid the
two drawbacks above.  To avoid being drawn in the vast complexity of
Julia type algebra, we focus on a minimal language featuring union
types, covariant tuples, and literals.  This tiny language is
expressive enough to highlight the decision strategy, and make this
implementation technique known to a wider audience.  While Julia
implementation shows that this technique extends, among others, to
invariant constructors and existential
types~\cite{DBLP:NardelliBPCBV18}, we expect that it
can be leveraged in many other modern language designs.  Additionally
we prove in Coq that the algorithm is correct and complete with
respect to a standard semantics subtyping model.


\section{A space-efficient algorithm}

The greatest difficulty of subtyping union types is searching the entire space
of possible forall/exist quantifications of union types. We have seen that
syntax-directed rules need ahead-of-time normalisation in the presence of
covariant tuples.

The algorithm we propose for deciding subtyping works by iterating through
choices made at unions along paths complete through the two types In this
section, we will describe the implementation of the algorithm in OCaml and
will present our proof of correctness in the following section.

We focus on a core type language composed of binary unions, covariant binary
tuples, and atom types:
\begin{small}
\begin{verbatim}
  type typ =
    | Atom of int
    | Tuple of typ * typ
    | Union of typ * typ
\end{verbatim}
\end{small}
Atom types are singletons with respect to subtyping, and are ranged
over by
\(A, B, ...\).  Abusing the
notation, we will assume that we also have unary
tuples; these can be easily encoded. 

\begin{figure}[h]
\center
\begin{tabular}{cc|cc|c}
\multicolumn{2}{c}{Stack} & \multicolumn{2}{c}{Type} & Base Query \\
\hline
$\forall$ & $\exists$ & $\forall$ & $\exists$ & \\
\hline
\goodcell L & \goodcell L & \goodcell \includegraphics[scale=0.3]{figures-gen/left1.pdf} & \goodcell \includegraphics[scale=0.3]{figures-gen/right1.pdf} 
    & \goodcell ${A} <: {A}$ \\
\goodcell L & \badcell R & \badcell \includegraphics[scale=0.3]{figures-gen/left1.pdf} & \badcell \includegraphics[scale=0.3]{figures-gen/right2.pdf}  
    & \badcell ${A} \not<: {B}$ \\
\hline
\goodcell R & \badcell L & \badcell \includegraphics[scale=0.3]{figures-gen/left2.pdf} & \badcell \includegraphics[scale=0.3]{figures-gen/right1.pdf}  
    & \badcell ${B} \not<: {A}$ \\
\goodcell R & \goodcell R & \goodcell \includegraphics[scale=0.3]{figures-gen/left2.pdf} & \goodcell \includegraphics[scale=0.3]{figures-gen/right2.pdf}  
    & \goodcell ${B} <: {B}$ \\
\hline
\end{tabular}

\hspace{1em}

$\tuple{\union{A}{B}} <: \union{\tuple{A}}{\tuple{B}}$

\caption{Subtyping decision procedure example}
\label{fig:cfs}
\end{figure}

As a running example we use the distributivity example from the
introduction:
$$\tuple{\union{A}{B}} <: \union{\tuple{A}}{\tuple{B}}$$
In Figure~\ref{fig:cfs} we sketch the corresponding
execution of the subtyping decision procedure.  Recall that to check
if the relation holds, the algorithm needs to ensure that for every choice 
that could be made at a union types on the left hand side of the
judgment there is a set of choices for the union types on the right hand
side such that subtyping holds. In this example, the relation holds: no
matter if we choose $A$ or $B$ on the left hand side inside the
covariant tuple, we can always pick a matching type on the right hand
side. The key challenge for a subtyping algorithm not based on
ahead-of-time normalisation is to enumerate
every possible choice of the components of the unions appearing in the
left and right hand sides of the judgments.

To do this, we base our approach on iterators. The \verb|st_choice|
type represents whether the algorithm takes the left (first) or the
right (second)
component of a union type:
\begin{small}
\begin{verbatim}
  type st_choice = Left | Right
\end{verbatim}
\end{small}
The algorithm stores
the choice made at each union at the present iteration in \emph{two stacks of}
\verb|st_choice|\emph{s}, one for each side of the subtype relation. 
Each \verb|st_choice| stack can be seen as the state of an iterator that
enumerates every union-type induced alternative in a given type.  One
stack will be used to ensure that all \emph{forall} choices have been
explored; the other stack to search for a matching \emph{exist} choice.
In figure~\ref{fig:cfs}, these are depicted as the $\forall$ and $\exists$ stacks.

It is possible to define both an initial element and next state function for
iterators defined using \verb|st_choice| stacks.

\begin{small}
\begin{verbatim}
  let rec initial_choice (a:typ) = 
    match a with
    | Atom i -> []
    | Tuple(t1,t2) -> (initial_choice t1) @ (initial_choice t2)
    | Union(l,r) -> Left::(initial_choice l)
\end{verbatim}
\end{small}
%  | Tuple1 t -> initial_choice t
We choose the initial value for our iterators to be the state where, every
time a union type is encountered in the structure of the type, the iterator
takes the \verb+Left+ choice (as implemented in \verb|initial_choice|
-- as we shall see when we will discuss the \verb+extend_list+
function, empty lists are expanded on demand with the appropriate
\verb+Left+ choices).

\begin{figure}
\begin{tabular}{cccc}
& \hspace{5em} & &\\
\includegraphics[scale=0.6]{figures-gen/example1.pdf} &
\multicolumn{2}{c}{\includegraphics[scale=0.6]{figures-gen/example2.pdf}} &
\includegraphics[scale=0.6]{figures-gen/example3.pdf} \\
L & \multicolumn{2}{c}{R} & RL \\
\multicolumn{2}{c}{last\_left\_to\_right} & \multicolumn{2}{c}{extend\_list} \\
\hline
\multicolumn{4}{c}{next\_state} \\
\end{tabular}
\caption{State-stepping operation for choice lists}
\label{fig:sstep}
\end{figure}

Given this definition for the initial state, we can then define the
iteration function. We break the iteration function,
\verb|next_state|, up into two helper functions. The operation of these
helpers is illustrated in figure~\ref{fig:sstep}. Here, starting from
the initial state (where the iterator takes the \verb+Left+ choice at the
root of the type), \verb|last_left_to_right| converts the final \verb+Left+ choice
into a \verb+Right+ choice and truncates the remaining choices.
\begin{small}
\begin{verbatim}
let rec last_left_to_right 
    (acc:st_choice list) (ll : st_choice list option) = function
  | Left::tl -> last_left_to_right (Left::acc) (Some (Right::acc)) tl
  | Right::tl -> last_left_to_right (Right::acc) ll tl
  | [] -> option_map List.rev ll
\end{verbatim}
\end{small}

For example, given the
type $\union{\union{A}{B}}{C}$ and the choice list \verb+LL+,
\verb|last_left_to_right| will produce the choice list \verb+LR+
(\verb+Left+ and \verb+Right+ are shortened here with \verb+L+ and
\verb+R+); if given \verb+LR+, it will produce \verb+R+ (as the final
left choice is at the top-level and it truncates the remainder of the
choice list).

In Figure~\ref{fig:sstep},
\verb|last_left_to_right| produced a partial path, as the right child of the root
union is a union itself. To solve this, \verb|extend_list| finds where the new
choice list runs out and fills it out with left choices to be valid with respect to the type,
producing a valid state. \verb|extend_list| pads the list out to take the left choice
at this child union, returning the path to validity.
\begin{small}
\begin{verbatim}
  let rec extend_list (a:typ) (ls:st_choice list) = match (a,ls) with
    | (Atom i, _) -> ([], ls)
    | (Tuple(t1,t2), _) -> let (hd,tl) = extend_list t1 ls in
                           let (hd2,tl2) = extend_list t2 tl in
                           (hd @ hd2, tl2)
    | (Union(l,r), Left::rs) -> let (hd,tl) = extend_list l rs in (Left::hd,tl)
    | (Union(l,r), Right::rs) -> let (hd,tl) = extend_list r rs in (Right::hd,tl)
    | (Union(l,r), []) -> (Left::initial_choice l,[])
\end{verbatim}
\end{small}


Finally, the \verb|next_state| function combines these operations into
a single step operation. It will take the deepest alternative choice
at a union using \verb|last_left_to_right|, then add however many left
choices are required to make the path valid using \verb|extend_list|. The
complete \verb|next_state| operation shown in figure~\ref{fig:sstep} takes
the choice stack L and the type $\union{A}{\union{B}{C}}$ and produces the
choice stack RL. To do so, it takes the left choice, converts it to a right,
then pads the list out with lefts until the path is valid with respect to the 
type.
\begin{small}
\begin{verbatim}
  let rec next_state (a:typ) (ls:st_choice list) =
    option_map fst (option_map (extend_list a) (last_left_to_right [] None ls))
\end{verbatim}
\end{small}


Now that we have defined the core iterator infrastructure, we show how it
is used to decide subtyping queries. The algorithm proceeds by maintaining two
iterators (one for each side of the subtyping judgment) over choices-at-unions,  
checking that for every instantiation of the left hand type there
exists an instantiation of the right hand type. We will first define the
fundamental subtyping relation, used to decide subtyping relationships when
given instantiations of the left and right hand types, then describe the
algorithm that iterates through those types.

\begin{small}
\begin{verbatim}
  type st_res =
    | Subtype of st_choice list * st_choice list
    | NotSubtype
\end{verbatim}
\end{small}

The type \verb|st_res| represents the results of a single base subtype query. The query
can either succeed, in which case it provides the unused portion of the input
stacks, or fail. 

\begin{small}
\begin{verbatim}
  let rec base_subtype (a:typ) (b:typ) (fa:st_choice list) (ex : st_choice list)
    match (a,b,fa,ex) with
    | (Atom i, Atom j, _, _) -> if i == j then Subtype(fa, ex) else NotSubtype
    | (Tuple(ta1, ta2), Tuple(tb1, tb2), _, _) ->
       (match base_subtype ta1 tb1 fa ex with
        | Subtype(cfa, cex) -> base_subtype ta2 tb2 cfa cex
        | NotSubtype -> NotSubtype)
    | (Union(a1,a2),b,choice::fa,ex) -> 
                base_subtype (match choice with Left -> a1 | Right -> a2) b fa ex
    | (a,Union(b1,b2),fa,choice::ex) -> 
                base_subtype a (match choice with Left -> b1 | Right -> b2) fa ex
\end{verbatim}
\end{small}

The function \verb|base_subtype| is responsible for using two
paths---one for the left and right hand sides of the subtyping
relation---and checking that the subtype relation holds with respect
to those paths. Given a basic type---an atom or a tuple---it will
either check equality or recur respectively. Given a union type, it
will choose the component of the union type following the choice
stacks and continue recursively. The function then returns an instance
of \verb|st_res|, which gives the remaining choice stacks if
successful or nothing otherwise.

\par
Finally, to check subtyping, we need to iterate through both types in the 
correct quantification order. Subtyping holds if, for every instantiation 
of the left there exists an instantiation of the right hand side of the
subtyping judgment such that the subtype relation holds. To check this,
we use a simple brute force approach sitting atop the choice stack iterator
infrastructure described previously. The algorithm is implemented in two
functions. \verb|ex_subtype| checks that there exists an instantiation
of the right-hand-side for a given left-hand-side. \verb|fa_ex_subtype|
uses \verb|ex_subtype| to check that for every instantiation of the LHS,
there is an instantiation of the RHS such that the subtype relation
holds. 
\par
\begin{small}
\begin{verbatim}
  let rec ex_subtype (a:typ)(b:typ)(fa:st_choice list)(cex : st_choice list) =
    match base_subtype a b fa cex with (* is a <: b *)
    | Subtype(_,_) -> true (* there exists a subtype *)
    | NotSubtype -> 
       (match next_state b cex with (* step exists-env *)
        | Some ns -> ex_subtype a b fa ns (* continue *)
        | None -> false) (* no subtype; exit *)
\end{verbatim}
\end{small}
If the current choice --- given by \verb|cex| --- is a supertype of the given \verb|a| according
to \verb|base_subtype|, then \verb|ex_subtype| has found a valid instantiation of \verb|b|. Therefore,
there exists an instantiation of \verb|b| that is a supertype of \verb|a| and the result should be true.
Otherwise, \verb|ex_subtype| will use the iteration operation, \verb|next_state|, to continue iterating
through choices for \verb|b| until it either finds an instantiation that is a supertype or runs out
of instantiations.

\begin{small}
  \begin{verbatim}
  let rec fa_ex_subtype (a:typ)(b:typ)(cfa:st_choice list) =
    match ex_subtype a b cfa (initial_choice b) with (* a <: b wrt path? *)
    | true -> (match next_state a cfa with
               | Some ns -> fa_ex_subtype a b ns (* continue *)
               | None -> true) (* all subtypes; is subtype *)
    | false -> false (* exists a non-subtype; not subtype *)
\end{verbatim}
\end{small}

The function \verb|fa_ex_subtype| is similar; it checks that for every
instantiation of \verb|a|, there exists an instantiation of 
\verb|b| such that subtyping holds. Checking for an instantiation
of \verb|b| is done using \verb|ex_subtype|, while \verb|fa_ex_subtype|
maintains an iterator for \verb|a|.

The operation of \verb|fa_ex_subtype| and \verb|ex_subtype| as well as their
calls to \verb|base_subtype| can be seen in figure~\ref{fig:cfs}. In the
$\forall$ column, we see the current state maintained by \verb|fa_ex_subtype|.
The $\exists$ column shows the state maintained by \verb|ex_subtype| as it is
called by \verb|fa_ex_subtype|. In the example, for a forall-list of L, we an
find an exists-list of L such that \verb|base_subtype| holds. Similarly,
for a forall-list of R, we can find an exists-list instantiation of R such
that subtyping holds. Therefore, for every instantaition of the left-hand-side,
there exists an instantiation of the right-hand-side such that subtyping holds
and subtyping holds for the type as a whole.


\begin{small}
\begin{verbatim}
  let rec subtype (a:typ) (b:typ) = fa_ex_subtype a b (initial_choice a)
\end{verbatim}
\end{small}

Finally, \verb|subtype| checks if \verb|a| is a subtype of \verb|b|.
It seeds \verb|fa_ex_subtype| with the initial choice for \verb|a|'s
iterator, which then checks if for every instantiation of \verb|a|
there exists an instantiation of \verb|b| such that subtyping holds.

We have presented our subtyping algorithm using lists of choices. In a
practical implementation, however, these lists of choices can be efficiently
implemented (without allocation) by means of bit sets. This is the approach
taken in the Julia implementation of this algorithm. With this optimization,
the needed memory to decide a subtyping judgment is linear in the total number
of unions in the given types; the algorithm needs no allocation beyond that
of the choice stacks themselves.

\section{Correctness and completeness}

To prove correctness of our algorithm, we begin by formally specifying
correctness for subtyping. We then show that two subtyping algorithms---
based on structural iterators and choice lists---are correct
with respect to this definition.

We base our definition of subtyping on a denotational semantics for types. 
We reduce types in the type language including unions to sets of types
in the type language without unions through a simple transformation. 

\begin{align*}
\denotes{\xt{A}} &= \{A\} \\
\denotes{\union{t_1}{t_2}} &= \denotes{t1} \cup \denotes{t2} \\
\denotes{\tuplet{t_1}{t_2}} &= \{\tuplet{t'_1}{t'_2} | t_1' \in \denotes{t_1},  t_2' \in \denotes{t_2'}\} \\
\end{align*}

Using this denotational semantics for types-with-unions, we can define
subtyping as if $\denotes{t_1} \subseteq \denotes{t_2}$, then $t_1 <: t_2$.
Equivalently, we can state this as definition~\ref{dfn:scr}, which is canonicalized
in our Coq proof as the \verb|NormalSubtype| relation.

\begin{definition}[Subtyping Correctness]
A subtyping relation $<:$ is correct if $t_1 <: t_2$ iff $\forall t_1' \in \denotes{t_1},
\exists t_2' \in \denotes{t_2}, t_1 <: t_2$.
\label{dfn:scr}
\end{definition}

Proving a subtyping algorithm sound and complete is therefore equivalent to
producing a function of type \verb|forall t1 t2:type, {NormalSubtype t1 t2} + {~NormalSubtype t1 t2}|; that is, is able to decide whether two types are
subtypes or not.

We will begin by describing and proving correct a version of the algorithm
that uses explicit type-structural iterators. We will then show the choice
stack-based algorithm correct by proving equivalence between structural
iterators and choice stacks. In doing so, we will derive an induction
principle for structural iterators (and, as an extension, for choice stacks).

\subsection{Iterators}

The iterator-based implementation is directly equivalent (as will be shown
later) to the choice-stack based implementation presented previously in OCaml.
However, it retains type structure information inside of the iterator state.

\begin{small}\begin{verbatim}
Inductive TypeIterator: type -> Set :=
| TIAtom : forall i, TypeIterator (atom i)
| TITuple : forall t1 t2, TypeIterator t1 -> TypeIterator t2 -> TypeIterator (tuple t1 t2)
| TIUnionL : forall t1 t2, TypeIterator t1 -> TypeIterator (union t1 t2)
| TIUnionR : forall t1 t2, TypeIterator t2 -> TypeIterator (union t1 t2).
\end{verbatim}\end{small}

The \verb|TypeIterator| structure follows the structure of the type being
iterated over. Choices at unions are represented as either an instance of
\verb|TIUnionR| or \verb|TIUnionL|. This structure then lets us trivially
define a function that extracts the current type at the iterator's position:

\begin{small}\begin{verbatim}
Fixpoint current (t:type)(ti:TypeIterator t):type :=
match ti with
| TIAtom i => atom i
| TITuple ti1 ti2 p1 p2 => tuple (current ti1 p1) (current ti2 p2)
| TIUnionL ti1 ti2 pl => (current ti1 pl)
| TIUnionR ti1 ti2 pr => (current ti2 pr)
end.
\end{verbatim}
\end{small}

\noindent We can then define a function that produces the initial iterator state for a
given type:

\begin{small}
\begin{verbatim}
Fixpoint start_iterator (t:type):TypeIterator t :=
  match t with
  | (atom i) => TIAtom i
  | (tuple t1 t2) => TITuple t1 t2 (start_iterator t1) (start_iterator t2)
  | (union t1 t2) => TIUnionL t1 t2 (start_iterator t1)
  end.
\end{verbatim}
\end{small}

\noindent Next, we can define a step function that takes one state and either steps it
to the next state or indicates that no such next state exists.

\begin{small}\begin{verbatim}
Fixpoint next_state (t:type)(ti:TypeIterator t) : option (TypeIterator t) :=
  match ti with
  | TIAtom i => None
  | TITuple ti1 ti2 p1 p2 =>
    match (next_state ti2 p2) with
    | Some np2 => Some(TITuple ti1 ti2 p1 np2)
    | None =>
      match (next_state ti1 p1) with
      | Some np1 => Some(TITuple ti1 ti2 np1 (start_iterator ti2))
      | None => None
      end
    end
  | TIUnionL ti1 ti2 pl =>
    match (next_state ti1 pl) with
    | Some npl => Some(TIUnionL ti1 ti2 npl)
    | None => Some(TIUnionR ti1 ti2 (start_iterator ti2))
    end
  | TIUnionR ti1 ti2 pr => option_map (TIUnionR ti1 ti2) (next_state ti2 pr)
  end.
\end{verbatim}\end{small}

With these definitions, we can then prove a basic form of correctness with
respect to the denotational or normalization semantics:

\begin{theorem}[Correctness of iterators]\begin{verbatim}
Remaining t (start_iterator t) (clauses t)
\end{verbatim}
Every type in $\denotes{t}$ will be explored using \verb|next_step| from \verb|start_iterator t|. 
\end{theorem}
\begin{proof}
The \verb|Remaining| predicate relates iterators to the list of types that remain to be iterated, so
the Coq theorem statement indicates that the initial state of the iterator for type $t$ has every clause
in the normalized version of $t$ remaining to be iterated.

We proceed by induction on $t$. The cases for atomic types and unions follow
from the IH trivially. We prove the theorem for tuples correct by case analyzing
on the number of clauses induced by the first element in the tuple, then identifying
the next element produced by the iterator from the tuple.

See \verb|iterator_has_clauses| in the Coq proof for full details.
\end{proof}

\verb|next_state| returns \verb|Some s| if there is some successor state
\verb|s| to the current, and \verb|None| if the given iterator state is
terminal. It will go left-to-right through unions, and will explore 2-tuples
by iterating through the choices on the right for each choice on the left. We can
then define an induction principle for type iterators based on \verb|next_state|:

\begin{theorem}
\begin{small}\begin{verbatim}
Definition iter_rect
  (t:type) (P:TypeIterator t -> Set)
           (pi: forall it, next_state t it = None -> P it)
           (ps : forall it' it'', P it'' -> next_state t it' = Some it'' -> P it')
           (it : TypeIterator t) : P it  
\end{verbatim}\end{small}

For any type \verb|t| and proposition \verb|P|, and if:
\begin{itemize} 
	\item \verb|P| holds for an iterator that has no next state (e.g. is done)
	\item if \verb|P| holds for the \emph{following} iterator state \verb|it|,
	then \verb|P| holds for the \emph{preceeding} iterator state \verb|it'|.
\end{itemize}
Then \verb|P| holds for all iterators for type \verb|t|
\end{theorem}
\begin{proof}
Proving the induction principle for type iterators relies on the \verb|iternum|
function, which decides the number of steps remaining in the iterator before termination.
The proof proceeds by simultaneous case analysis on the number of remaining states and
whether the iterator step function can produce a successor state from the present state.

If the iteration number is not yet 0, and if there is a successor state, then
we simply  appeal to the induction hypothesis and continue on. If there is no
successor state but  the iteration number is nonzero or vice versa, then by
lemma (\verb|iternum_monotonic|, taking an iterator step decrements the
iteration number) contradiction. Finally, if there is no next step and the iteration
number is 0, then we have reached the base case and terminate.

For full details, see the Coq definition of \verb|iter_rect|.
\end{proof}

Using \verb|iter_rect|, we can implement and prove correct equivalent functions
to \verb|ex_subtype|, \verb|fa_ex_subtype|, and \verb|subtype| as described in the
OCaml implementation.

\begin{small}\begin{verbatim}
Definition exists_iter(a b : type) : 
  ({ t | InType t b /\ BaseSubtype a t } +
   {forall t, InType t b -> ~(BaseSubtype a t) }).
\end{verbatim}\end{small}

\verb|exists_iter| is equivalent to the choice-stack based \verb|ex_subtype|,
and determines if there exists some denotationally-contained type in \verb|b|
that is a supertype of the given \verb|a|. Internally, it is implemented in 
the same way as \verb|ex_subtype|, though using \verb|iter_rect| to iterate 
through every iterator state.

\begin{small}\begin{verbatim}
Definition forall_iter (a b : type) :
  { forall t, In t (clauses a) -> exists t', InType t' b /\ (BaseSubtype t t')} +
  { exists t, In t (clauses a) /\ forall t', InType t' b -> ~ (BaseSubtype t t')}.
\end{verbatim}\end{small}

\verb|forall_iter| is to \verb|fa_ex_subtype| what \verb|exists_iter| is to
\verb|ex_subtype|. Like \verb|exists_iter| it implements the same decision procedure
as \verb|fa_ex_subtype| (and internally relies upon \verb|exists_iter|), though through
the abstraction of \verb|iter_rect|.

Finally, we can define a decidable function (called \verb|subtype| in the proof)
that decides whether two types are subtypes or not. \verb|subtype| simply invokes
\verb|forall_iter| to decide subtyping.

\begin{small}\begin{verbatim}
Definition subtype(a b:type) : {NormalSubtype a b} + {~NormalSubtype a b}.
  destruct (forall_iter a b).
  - left. [...]
  - right. [...]
Defined.
\end{verbatim}\end{small}

\noindent Therefore, using iterators, we can decide whether subtyping holds for any two types
in our language. We will now show an equivalence between iterators and stacks-of-choices,
allowing for more efficient implementation.

\subsection{Stacks}

To show that the choice-stack based algorithm is correct, we reduce it to the
already-shown-correct iterator-based algorithm for deciding subtyping. To do so,
we show an equivalence between choice stacks and iterators, then prove correctness
of the subtyping algorithms.

In the context of the Coq proof, we use the type \verb|st_context| to refer
to a choice stack. In Coq, this is represented as a list of boolean values,
with false representing a left choice and true representing a right choice at
a specific union.

To show equivalence between the iterator-based and stack-based algorithm, we need to
first prove two properties:

\begin{itemize}
  \item iterators are convertible to equivalent choice lists;
  \item stepping an iterator is equivalent to stepping a choice list.
\end{itemize}

We define an iterator and a choice stack to be equivalent if, when applied to
the same type, they select the same subset of that type. To describe this, we
define \verb|lookup_path| which looks up what type is selected by a given
choice stack.

\begin{small}\begin{verbatim}
Fixpoint lookup_path(t:type)(p:st_context) : type * st_context :=
  match t, p with
  | atom i, _ => (t, p)
  | tuple t1 t2, _ =>
    let (r1,p1) := lookup_path t1 p in
    let (r2,p2) := lookup_path t2 p1 in
    (tuple r1 r2, p2)
  | union l r, false::rs => lookup_path l rs
  | union l r, true::rs => lookup_path r rs
  | _, nil => (t, nil)
  end.
\end{verbatim}\end{small}

\verb|lookup_path| is notable in that it both returns the selected type as
well as whatever of the choice stack remains once it reaches a leaf. This is
needed in order to be able to traverse types that contain tuples,  whose left
branches will potentially be given a longer choice stack then necessary.

Next, we can convert iterators to paths in the straightforward manner, as
implemented by \verb|iterator_to_path|:

\begin{small}\begin{verbatim}
Fixpoint iterator_to_path(t:type)(it:TypeIterator t):st_context :=
   match it with
   | TIAtom _ => nil
   | TITuple t1 t2 it1 it2 => (iterator_to_path t1 it1) ++ (iterator_to_path t2 it2)
   | TIUnionL t1 _ it1 => false :: (iterator_to_path t1 it1)
   | TIUnionR _ t2 it1 => true :: (iterator_to_path t2 it1)
   end.
\end{verbatim}\end{small}

\verb|iterator_to_path| simply traverses the iterator in order, appending onto the
output choice stack whatever choice the iterator makes at that union. This illustrates
the equivalence between iterators and choice stacks; choice stacks are simply iterators
with the structural information removed.

Using the combination of \verb|lookup_path| and \verb|iterator_to_path|, we
can then show the first correctness property that we need to prove that the
algorithm using choice stacks is correct:

\begin{lemma}[Iterator to path is correct]
\begin{small}\begin{verbatim}
Lemma itp_correct : forall t it, 
  current t it = fst (lookup_path t (iterator_to_path t it)).
\end{verbatim}\end{small}

For every type \verb|t| and type iterator \verb|it|, the iterator's current type \verb|current t it| is equal
to the result of looking up the conversion of \verb|it| to a choice stack.
\end{lemma}
\begin{proof}
See \verb|itp_correct| in the Coq proof.
\end{proof}

Stepping in the Coq implementation is implemented identically to the OCaml
implementation. It only remains to show that this step operation (called
\verb|step_ctx| in Coq) is correct with respect to the iterator
\verb|next_state|.

\begin{lemma}[Correctness of step\_ctx]
\begin{small}\begin{verbatim}
forall t it,
    step_ctx t (iterator_to_path t it) =
    (option_map (iterator_to_path t) (next_state t it)).
\end{verbatim}\end{small}
For every type \verb|t| and type iterator \verb|it|,
stepping the choice-list equivalent of \verb|it| will
produce the same result as converting the result of stepping
\verb|it|.
\end{lemma}
\begin{proof}
See \verb|list_step_correct| in the Coq proof.
\end{proof}

Now, with the relevant properties proven, we can implement and prove correct
\verb|ex_subtype| and \verb|fa_ex_subtype| in Coq. The function names are the
same, as are the implementations up to the addition of a fuel parameter (which
is shown to be unnecessary). 

\begin{lemma}[Correctness of existential subtype checking with choice stacks]
\begin{small}\begin{verbatim}
forall a b it, 
  (exists pf, exists_iter_inner a b it = inleft pf) <->
   exists n, ex_subtype a b (iterator_to_path b it) n = Some true.
\end{verbatim}\end{small}
For every two types \verb|a| and \verb|b|, the iterator-based algorithm
\verb|exists_iter_inner| will produce a proof that \verb|a| is a subtype
of \verb|b| if and only if there is an integer \verb|n| such that
 \verb|ex_subtype| given \verb|n| fuel runs producing true.
\end{lemma}
\begin{proof}
See \verb|ex_sub_corr_eq| in the Coq proof.
\end{proof}

\begin{lemma}[Correctness of forall-exists subtype checking with choice stacks]
\begin{small}\begin{verbatim}
forall a b it,
   (exists pf, forall_iter_inner a b it = left pf) <->
    exists n, fa_ex_subtype a b (iterator_to_path a it) n = Some true.
\end{verbatim}
\end{small}  
For every two types \verb|a| and \verb|b|, the iterator-based algorithm
\verb|forall_iter_inner| will produce a proof that \verb|a| is a subtype
of \verb|b| if and only if there is an integer \verb|n| such that
 \verb|fa_ex_subtype| given \verb|n| fuel runs producing true.
\end{lemma}
\begin{proof}
See \verb|fa_sub_corr_eq| in the Coq proof.
\end{proof}

The choice stack-based algorithm therefore is provably equivalent to the
iterator-based algorithm, and is thus correct.


\section{Conclusion}

We have presented an algorithm for deciding subtyping relationships between
types that consist of atomic types, tuples, and unions. This algorithm is able
to decide subtyping relationships in the presence of distributive semantics
for union types without needing normalization (and therefore using linear
space) and without additionally constraining type system features.

%\bibliographystyle{plain}
\bibliography{refs}

\end{document}
